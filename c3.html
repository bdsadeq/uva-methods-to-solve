<div data-page="10300" class="page">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="left"><a href="index.html" class="back link icon-only"><i class="icon icon-back"></i></a></div>
            <div class="center">Volume 103 (10300-10399)</div>
        </div>
    </div>

    <div class="page-content">
        <div class="content-block">



            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10300 - Ecological Premium">10300 - 
                        Ecological Premium</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Compute the premium, just ignore total_animal. Very very easy. =)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10301 - Rings and Glue">10301 - 
                        Rings and Glue</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You can solve this problem using backtracking. 
                The main consideration is how you compute that 2 rings intersect... </font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">First, compute the distance between 2 center 
                of rings.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">If this distance greater than total radius of 
                ring 1 and ring 2, then these 2 rings are separated too far, no 
                intersection... ignored</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">If this distance equal with total radius of 
                ring 1 and ring 2, then these 2 rings are touching each other, but only in 
                one intersection... ignored</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">If this distance + minimum of (radius ring 
                1,radius ring 2) smaller than maximum of (radius ring 1, radius ring 2), 
                then one of this ring is inside of the bigger ring, again there is no 
                intersection... ignored</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Otherwise, they are intersect, count this.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10302 - Summation of Polynomials">
                        10302 - 
                        Summation of Polynomials</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">I'm not a Math expert... I cannot derive the 
                formula using my brain... However I found this formula from my high school 
                textbook, just use this to get Accepted: <u><b>(x/2)^2 * (x+1)^2</b></u></font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10303 - How Many Trees">10303 - 
                        How Many Trees?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">See my explanation for problem 10007, very 
                similar... But this time you don't need to time the result with N!</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10304 - Optimal Binary Search Tree">10304 - 
                        Optimal Binary Search Tree</a> (by: Limon) - I haven't solve this</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This problem is just like matrix chain multiplication</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Keep a track of the root of all tree<br>
                in the third loop instead of k= i to j<br>
                write k=root[i][j-1] to root[i][j+1]<br>
                update root as well as the cost<br>
                because the root of tree [i to j] must not be to the left of root of the 
                tree [i,j-1] and must not be right to the root of the tree[i+1,j]</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This will reduce complexity of the three loop to O(n^2).</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10305 - Ordering Tasks">10305 - 
                        Ordering Tasks</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Read the input, and do Hill Climbing algorithm (Artificial Intelligence 
                term), which means: keep repeating the rules until there is no more 
                violation to any single rule. If there is a violation, swap the elements, 
                and keep checking. </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10309 - Turn the Lights Off">10309 - 
                        Turn the Lights Off</a> (By: Yandry)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Use Gauss method to solve systems of linear equations.<br>
                <br>
                You can obtain 100 equations from the grid that is given in the input, for 
                example:<br>
                <br>
                simple<br>
                #O########<br>
                OOO#######<br>
                #O########<br>
                ####OO####<br>
                ###O##O###<br>
                ####OO####<br>
                ##########<br>
                ########O#<br>
                #######OOO<br>
                ########O#<br>
                <br>
                As the light that is in the upper left corner changes its state when we 
                press it, or we press the one at its left, or we press the one at its 
                bottom, we can obtain the equation:<br>
                <br>
                numberofpresseslight1 + numberofpresseslight2 + numberofpresseslight11 = 
                evennumber<br>
                <br>
                Because we must change its state an even number of times since we want it 
                turned off in the final state.<br>
                <br>
                So, you can obtain the 100 equations in the same way and then apply Gauss 
                elimination, using the following rules:<br>
                <br>
                a(plus)b=(a+b)%2<br>
                a(minus)b=(a-b)%2<br>
                <br>
                or you may want to use XOR.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10310 - Dog and Gopher">10310 - 
                        Dog and Gopher</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                You need to find a hole where dist(dog,hole) &gt;= 2.0*dist(gopher,hole).
                The only main problem here is the precision error.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                However, you can remove the square root in dist() function and transform the 
                above equation to:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                distWithoutSqrt(dog,hole) &gt;= (2.0^2)*distWithoutSqrt(gopher,hole)<br>
                distWithoutSqrt(dog,hole) &gt;= 4.0*distWithoutSqrt(gopher,hole)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10311 - Golbach and Euler">10311 - 
                        Golbach and Euler</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Prime Numbers again...<br>
                some interesting properties:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                if n &lt; 3, obviously not a sum of two primes (smallest prime 2+2 = 4)<br>
                if n is odd, only 2 + (n-2) is the feasible summation<br>
                if n is even, you must check it all</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Use a good and fast prime number generator (such as Sieve) to solve this 
                problem. </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10323 - Factorial! You Must be Kidding!!!">10323 - 
                        Factorial! You Must be Kidding!!!</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                The only tool that you need is a "long long" data structure... Surprised? me 
                too... simply declare a 'long long' variable, and just do the factorial 
                calculation. Check whether this value is within 10.000 and 6.227.020.800.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                HOWEVER!!!, I don't know how come there is a negative input for this problem 
                (I know this from message board). if -even number =&gt; output Underflow!, if 
                -odd number =&gt; output Overflow!...</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Don't ask me whether there exist a negative factorial... I also unsure...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10324 - Zeros and Ones">10324 - 
                        Zeros and Ones</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Declare an integer array "change_counter" with size 1000001, all elements 
                initialized to 0. Now scan the 0-1 input once, every time you encounter a 
                change, increase the counter value. Now anytime you want to know elements 
                within two indices consists of all '0' or all '1', you can simply check 
                whether the change_counter[index1] equal to change_counter[index2]</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Example: 101001<br>
                Change counter: 0,1,2,2,2,3<br>
                If you ask 0-2, then return false (0 != 2)<br>
                If you ask 2-4, then return true (2 == 2)<br>
                and so on</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10327 - Flip Sort">10327 - 
                        Flip Sort</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Exactly similar to 299 - Train Swapping. Count the number of bubble sort 
                swaps O(N^2) or you can do better using inversion index counting (Merge Sort) 
                ~ O(N*log N).</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10334 - Ray Through Glasses">10334 - 
                        Ray Through Glasses</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                It is a fibonacci pattern, but use Big Integer since the values are very big.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10336 - Rank the Languages">10336 - 
                        Rank the Languages</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Read the input data into 2 dimensional array. Then do floodfill for each 
                region + counting this region. Output the result in decreasing order of 
                frequency.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10337 - Flight Planner">10337 - 
                        Flight Planner</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This is similar to problem 116. A left to right scanning (using DP). 
                Formulate this problem as DP. You know that for each step, you can only have 
                3 possibilities: either climb, hold, sink, with their respective wind 
                properties.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10338 - Mischievous Children">10338 - 
                        Mischievous Children</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Standard formula: N! / (any similar letter)!</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Example:<br>
                HAPPY, similar letter: 'A' occurs twice, Output: 5!/2! = 60<br>
                WEDDING, similar letter: 'D' occurs twice, Output: 7!/2! = 2520<br>
                ADAM, similar letter: 'A' occurs twice, Output: 4!/2! = 12<br>
                AAAA, similar letter: 'A' occurs 4 times, Output: 4!/4! = 1<br>
                AABB, similar letter: 'A' occurs twice, 'B' occurs twice, Output: 4!/(2!*2!) 
                = 6</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                However, since 12! already outside the limit of unsigned long, how to 
                calculate 20! ??<br>
                I was once tried solving this problem using p369 tricks, but got TLE... <br>
                The answer is: use "long long" and just directly calculate 20!, "long long" 
                can handle 20! :)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10340 - All in All">10340 - All in 
                        All</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                The greedy solution works, i.e. use a pointer into the supposed sub-sequence 
                that is advanced if a character matches while you iterate through the 
                super-sequence.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10344 - 23 Out of 5">10344 - 23 Out 
                        of 5</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">"bijective 
                function" for "pi" means that the order of operands "a" can be reordered 
                within range 1-5. i.e. a1 can be swapped with a3, a2 with a4, and so on. 
                There are roughly 5! = 120 possible combinations of rearranging the 
                operands.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Operators can be either +,-,or *, and there exist 4 slots, therefore there 
                are only 3^4 = 81 possible combinations for rearranging the operators.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Backtracking will be able to perform those shuffles easily. For each 
                combination, evaluate the expression (remember the brackets!!!), is the 
                result 23? If any of the combinations can reach 23, output "Possible", 
                otherwise output "Impossible".</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Example:<br>
                1 2 3 4 5 =&gt; (((1*2)+4)*3)+5 = ((2+4)*3)+5 = (6*3)+5 = 18+5 = 23, Possible</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10346 - Peters Smoke">10346 - 
                        Peter's Smoke</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Find the pattern and derive the following formula (total_cigar and butt 
                initally set to 0) and simply simulate the process...</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                while (n &gt; 0) {<br>
                &nbsp; total_cigar += n; /* accumulate all new cigars so far */<br>
                &nbsp; butt += n; /* after Peter 
                smokes these n cigar, we have n butts */<br>
                &nbsp; n = butt / k; /* so these n butts become new cigars */ <br>
                &nbsp; butt %= k; /* butts left are reserved for future cigars */<br>
                }</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10347 - Medians">10347 - 
                        Medians</a> (by: Sohel Hafiz)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Area = 4/3 * sqrt( s * ( s - m1 ) * (s - m2)&nbsp;* ( s - m3 ) );<br>
                &nbsp;<br>
                where m1, m2 and m3 are the three medians and<br>
                s = 0.5 *&nbsp;( m1 + m2 + m3 );<br>
                &nbsp;<br>
                So output the area if:&nbsp;s * ( s - m1 ) * (s - m2)&nbsp;* ( s - m3 ) &gt; 0.<br>
                &nbsp;<br>
                Critical part is that you have to output -1.000 for invalid combinations.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10354 - Avoiding Your Boss">10354 - 
                        Avoiding Your Boss</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                I haven't try this, but quick look at the problem description give me a 
                glimpse of this algorithm:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                1. Find the shortest path of Boss (OF, office to BH, Boss's home)<br>
                2. Remove all nodes (and all edges adjacent to it) used in the previous 
                shortest path<br>
                3. If (YH, your home or M, market) removed in step 2, output MISSION 
                IMPOSSIBLE<br>
                4. If in any means you can't reach M from YH, output MISSION IMPOSSIBLE<br>
                5. else output the shortest path</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10356 - Rough Roads">10356 - 
                        Rough Roads</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                I haven't try this. However this problem is about finding shortest path with 
                even length using the rule given in the problem.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10360 - Rat Attack">10360 - 
                        Rat Attack</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Tackle this problem the other way round... Declare 1025*1025 sized array, 
                initialized to all 0. Each array element represent the coordinate of grid 
                world. For each rat position, add <b>+ population</b> to every cells within radius d. After 
                that, scan this 1025*1025 from top,left coordinate to find the biggest 
                value... place your bomb here.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10361 - Automatic Poetry">10361 - 
                        Automatic Poetry</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Read the input pairs, tokenize first line into 5 strings s1,s2,s3,s4,s5, 
                then print this first line as usual, but without '&lt;' or '&gt;'. For the second 
                line, print the original up to '...', then print s4,s3,s2,s5. Very easy...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10363 - Tic Tac Toe">10363 - 
                        Tic Tac Toe</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This problem is easy but tricky... Firstly, you have to count how many 'X' 
                and 'O', then you must decide who win and not win (neither win is possible), 
                and then use the following rule:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                1. X starts first, so at least X==O or X==O+1<br>
                2. Either X win and O not win and X==O+1,<br>
                &nbsp;&nbsp;&nbsp; or O win and X not win and X==O,<br>
                &nbsp;&nbsp;&nbsp; or neither win<br>
                3. nothing else</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10365 - Blocks">10365 - 
                        Blocks</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                To wrap the gifts, Donald need to stack the boxes into rectangular solid. He 
                need to arrange the items in such a way. The key is that the volume are 
                still the same!!!</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                So find all possible combination of height h, length l and width w such that 
                h * l * w == n (because there are n boxes with size 1*1*1 = 1 inch^3)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Among all these possible h,l,w combinations, choose the one that has the 
                smallest area.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10370 - Above Average">10370 - 
                        Above Average</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Simply count the average (can be done on the fly while reading the input), 
                and then print out the percentage of students which are above this average.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10371 - Time Zones">10371 - 
                        Time Zones</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Straightforward problem. Just follow the problem description.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10377 - Maze Traversal">10377 - Maze 
                        Traversal</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Read the input carefully (a bit tricky), then simply simulate the movement 
                of the robot.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10382 - Watering Grass">10382 - 
                        Watering Grass</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Let's analyze.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Courier" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                r /|<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; | 0.5*w<br>
                |-c--*--c-|-----------<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp; |<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \|&nbsp; </font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                See the ASCII art above. Sprinkler with origin * and radius r, actually can 
                only fully covers up to length c...&nbsp; which can be calculated via c = 
                r^2-(1/2w)^2.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Thus maximum coverage of a sprinkler is actually [left = position-c, right=position+c].<br>
                Sort the sprinklers based on the left value. Then greedily choose sprinklers 
                that covers the longest, this will be the minimum.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10393 - The One-Handed Typist">10393 - 
                        The One-Handed Typist</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Straightforward problem. Just follow the problem description.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10394 - Twin Primes">10394 - Twin 
                        Primes</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Pre-generate primes up to 2.000.000 using Sieve algorithm, and then record 
                prime p which p+2 also a prime number. The implementation detail is up to 
                you, however the most important thing is to effectively generate the primes.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10397 - Connect the Campus">10397 - 
                        Connect the Campus</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This problem is very very similar to 10147-Highways. You are given a list of 
                buildings in campus and a set of pre-defined edges. Now you need to expand 
                the partial-Minimum Spanning Tree. That's it..., Kruskal's MST algorithm is 
                very suitable for this problem. :)</font></p>




        </div>
    </div>
</div>
