<div data-page="600" class="page">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="left"><a href="index.html" class="back link icon-only"><i class="icon icon-back"></i></a></div>
            <div class="center">Volume 6 (600-699)</div>
        </div>
    </div>

    <div class="page-content">
        <div class="content-block">




            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="601 - The PATH">601 - 
                        The PATH</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You can use DFS... but it is a bit 
                troublesome... A better way is to flood fill from left to right, replacing 
                'w' with some other character, say '1', and check whether in the rightmost 
                column, there exist a '1', if yes, white already have the winning path.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">If no '1' exist in the rightmost column, 
                then do flood fill from right to left (opposite direction), replacing all 
                'w' with another character, say '2'... then check whether there exist an 
                unfilled cell which have '1' on the left and '2' on the right, which means 
                using one more move, white will win...</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Same reasoning for black, but this time from 
                top to bottom...</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">If nothing can be concluded, output there is 
                no winner.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="602 - What Day Is It">602 - 
                        What Day Is It?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Using the Julian &amp; Gregorian date rule, you 
                are asked to determine the day if valid or print error message otherwise. 
                I can say that this is a complex problem and need sufficient knowledge of 
                calendar system. Good luck.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Anyone want to add more explanation for this 
                problem?</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="612 - DNA Sorting"><font face="Verdana" size="2">612 - 
                        DNA Sorting</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">If you analyze the problem 
                carefully, you'll then realize that "sortedness" here means "how 
                many bubble sort steps we need". After knowing all "bubble sort 
                steps", we can then rearrange the input according to their "sortedness".</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Read all input, store it into an 
                array.<br>
                Do a bubble sort for each items in array (use temporary 
                variable, sort that variable, not the original, we need them for 
                the output)<br>
                Count how many steps we need to make them sorted.<br>
                From ``most sorted'' to ``least sorted'', print them.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="614 - Mapping the Route">614 - Mapping the Route</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem itself is not 
                difficult, just use the algorithm given in the problem 
                description. The problem is the output format. In my solution, I use a string buffer to store 
                temporary output, modify this output, after everything is ok, I 
                print the string buffer. You must remember that for every movement, you must start 
                from West-&gt;North-&gt;East-&gt;South direction again, not from the 
                last direction.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="615 - Is It A Tree">615 - 
                        Is It A Tree?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Check whether the given graph is a 
                tree or not. Refer to your data structures book.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="616 - Coconut, Revisited">616 - 
                        Coconut, Revisited</a> (why WA?)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Just simulate the division process up to 
                sqrt right??... I wonder what's wrong...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="617 - Nonstop Travel">617 
                        - Nonstop Travel</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Do a brute force complete search 
                from speed 30 mph to 60 mph. To avoid loss precision, use fmod (floating 
                point modulo) instead of mod (integer modulo) and be careful in formatting 
                the output.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="620 - Cellular Structure">620 - Cellular Structure</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Do a recursive check of the grammar. 
                Shouldn't be too difficult.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="621 - Secret Research"><font face="Verdana" size="2">
                        621 - Secret Research</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">positive result S = 1 or S = 4 or 
                S = 78<br>
                negative result S = S35<br>
                experiment failed S = 9S4<br>
                experiment not completed S = 190S</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Actually this problem can be very 
                easy once you know what it means (or when you read this hint). How to know which output we have 
                to give for each input? The answer is simple:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Positive when S is exactly 
                "1","4",or "78"<br>
                Negative when the last two digits of S are exactly "35"<br>
                Experiment failed if the first digit of S is exactly "9" and the 
                last one digit of S is exactly "4"<br>
                Experiment not completed if the first three digits are exactly 
                "190"</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="622 - Grammar Evaluation">622 - Grammar Evaluation</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">There is no trick in this problem, just 
                recursively check the expression using the given grammar. Check whether 
                these simple test cases are passed:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">7<br>
                1+2<br>
                1++2<br>
                1**2<br>
                1)(2<br>
                (12)<br>
                (12)*(12)<br>
                (1+2)*(2*3)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">3<br>
                ERROR<br>
                ERROR<br>
                ERROR<br>
                12<br>
                144<br>
                18</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="623 - 500!">623 
                        - 500!</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A simple factorial problem, and the maximum 
                size is "not 500", but 1000... They said 500 is "too small" :p. If you 
                have your Big Integer library ready, just do it...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="624 - CD">624 
                        - CD</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Just do an exhaustive backtracking search 
                with effective pruning.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="626 - Ecosystem">626 
                        - Ecosystem</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Max N ?? only 100, simply set a three nested 
                loop i,j,k from 1 to n...<br>
                Print the indexes and increase total if i&lt;j&lt;k or i&gt;j&gt;k and i eat j, j eat 
                k and k eat i...<br>
                Finally output total possibilities accumulated so far.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="627 - The Net">627 
                        - The Net</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simple Graph Traversal problem. Either BFS 
                or DFS will do. Just make sure you output the path with lowest IDs if 
                there are more than one minimum path...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="630 - Anagrams (II)"><font face="Verdana" size="2">630 
                        - Anagrams (II)</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">If you generate all the anagrams 
                of the word first then, compare it one by one with the 
                dictionary, you will get Time Limit Exceeded.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A better approach is to compare 
                each element in dictionary with the word using my checkAnagram() 
                function (see programming section).</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="636 - Squares (II)">636 - Squares (II)</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Trial and Error... start from smaller base 
                number one by one until you found the answer. </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="637 - Booklet Printing">637 - Booklet Printing</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Take two or more pieces of paper 
                and try to make a booklet from these piece of papers <b>manually</b>, then 
                just simulate what human will do to a code.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="640 - Self Numbers">640 - 
                        Self Numbers</a> (by: James Chew)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Dynamic Programming is required 
                here. Prepare a big array of 1,000,000 elements, and then 
                generate all the numbers from bottom up. After that, output the numbers 
                that has no generator (self numbers).</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="641 - Do the Untwist">641 - 
                        Do the Untwist</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Just reverse the formula and decrypt it... 
                straightforward...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="642 - Word Amalgamation">642 - Word 
                        Amalgamation</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This is just an anagram checker problem. 
                Sort the dictionary, record the frequency of each letter in the words. And 
                then when you are given a scrambled word, output all their anagrams, which 
                will be lexicographically sorted by default if you have sort the 
                dictionary.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="644 - Immediate Decodability">644 - 
                        Immediate Decodability</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Brute force... only maximum 8 codes, each 
                code only have at max 10 bits... try all nC2 (n Choose 2) possible 
                pairings and check whether bit i and bit j is a prefix of each other... 
                total brute force...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="647 - Chutes and Ladders">647 - 
                        Chutes and Ladders</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">My childhood game :). This problem is just a 
                simple but tedious game simulation. You must carefully read the problem 
                description (the game rule), and then simulate it. </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="654 - Ratio"><font face="Verdana" size="2">654 - Ratio</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">From a given numerator A and 
                denominator B, construct ratios starting with denominator 1 
                which closest to the actual value of A/B. Keep computing ratios 
                that are getting closer and closer to the actual value until our 
                approximation equal to A/B.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="657 - The die is cast"><font face="Verdana" size="2">
                        657 - The die is cast</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Tricky flood fill problem. After 
                counting the number in a dice, delete that dice to make sure 
                subsequent counting will not count that dice anymore.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="663 - Sorting Slides">663 - Sorting 
                        Slides</a> (by: MD Erfan Hoque)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Construct the following graph: <br>
                1 to n nodes for the slides,n+1 to n+n nodes for the numbers.<br>
                edge from the slides to the possible numbers.<br>
                <br>
                Now Run your maximum Bipartite matching algorithm and find<br>
                all match. For all match edges flip the direction of the edges.<br>
                Now start a DFS which start from i node and return back in<br>
                again at i node[i.e i=1 to n].If for any i it is not possible<br>
                to return at i then it is correct match to choose the jth number<br>
                for ith point where i and j is match edge and output this pair.<br>
                If no pair found to output then output is none as problem description.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="665 - False Coin">665 - False Coin</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A bit similar to problem 608, this problem 
                ask the same question, which one is false/counterfeit coin. If I'm not 
                mistaken you can use the same concept as 608.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="670 - The dog task">670 - The dog 
                        task</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem is a Network Flow (more 
                precise, Maximum Bipartite Matching) problem. Find the best matching for 
                the Bob's positions and interesting places.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You have to construct the bipartite graph 
                first. Add an edge if from Bob's position, the dog can visit the 
                interesting place and go back to Bob without violating the constraint (the 
                dog's round trip distance can't be more 2 times Bob's distance). After 
                that, just pass this graph to your Network Flow or Maximum Bipartite 
                Matching algorithm to get the result.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="671 - Spell checker">671 - Spell 
                        checker</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Very straightforward. Read in the 
                dictionaries (you don't need to sort this...you will have to check all 
                elements anyway...), then read the query words.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">If this query word matches any of them, 
                output that this word is correct.<br>
                If this query word differs by insert/delete/or change one char, add this 
                to our match list, at the end, output this list.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="673 - Parentheses Balance">
                        <font face="Verdana" size="2">673 - Parentheses Balance</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You have to check whether a given 
                string containing brackets is correct or not. Solution:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1. You can do stack-based solution, 
                pushing every time you encounter open bracket and popping 
                every time you encounter matching close bracket. <br>
                2. Or, you can do what I did, Do a 
                looping from 1 to the first occurrence (Forward) of close 
                bracket, then from that point, move backward to the first 
                occurrence of open bracket, then cut that portion of string. 
                Do this until we get empty string (It's a balanced 
                parentheses) or when we cannot do any more search (Unbalanced 
                parentheses).</font></p><p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Example of the second 
                implementation</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">(()) Original string<br>
                ((<b>)</b>) First search, found ) at index 3<br>
                (<b>(</b>)) Go back, found ( at index 2<br>
                ()&nbsp;&nbsp; Delete that portion of string<br>
                (<b>)</b>&nbsp;&nbsp; Second search, found ) at index 2<br>
                <b>(</b>)&nbsp;&nbsp; Go back, found ( at index 1<br>
                &nbsp;&nbsp;&nbsp;&nbsp; Empty string, it's a balanced parentheses.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Please note that empty string is by default correct 
                and there are <u>two</u> 
            types of bracket "()" and "[]", each of them must be treated 
            differently.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="674 - Coin Change"><font face="Verdana" size="2">674 - 
                        Coin Change</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Another coin changing problem.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Note:<br>
                Coin Changing problem also found in problem 147 (Dollars) and 
                problem 357 (Let Me Count The Ways). You can solve 3 problems 
                using one similar source code.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="677 - All Walks of length ``n from the first node">677 
                        - All Walks of length ``n'' from the first node</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simple Depth First Search (bounded 
                to depth ``n'').
                You don't have to consider the Boolean matrix multiplication 
                given in the problem description, it has no effect. Just don't forget to print "no walk of 
                length n" if there is no walk of length n.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="679 - Dropping Balls">679 - Dropping Balls</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A problem that makes you think of 
                efficiency to the limit =). I have to try several times to get this one 
                accepted. Direct simulating the process is impossible since 2^20 is too 
                big for your memory (and even if you have that memory, you don't pass 
                that annoying 10 seconds Time Limit).</font></p><p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">After a careful study of Binary Tree 
                properties... I derive the following formula, which is definitely a 
                cheat if you directly copy this without reading below :p</font></p><p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The formula:</font></p><p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Courier New" size="2">P=1;<br>
                for (j=0;j&lt;D-1;j++) {<br>
                &nbsp; P=I%2!=0 ? 2*P : 2*P+1; /* go to left or right? */<br>
                &nbsp; I=(I+1)/2; /* round up */<br>
                }</font></p><p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">P is the final value that we want to find 
                (one of the leaves of binary tree), so we loop from 0 to D-1 (yes, this 
                means we compute only the non terminal nodes). For each non terminal 
                nodes, we check whether I is multiples of two, if no, we go to the left 
                (remember, in a tree, left index is 2*parent index and right index is 
                2*parent index+1), if yes, we go to the right. Finally we divide the 
                value of I by 2 (rounded up).</font></p><p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Why this formula is true? The root (1st 
                level) will be toggled (yes, TOGGLED!!!, this is the key for efficiency) 
                I times, Nodes on the 2nd level will be toggled I/2 (rounded up) times, 
                ..., Nodes on kth level will be toggled I/(2^(k-1)) times. And toggles 
                means binary, and binary is related with modulo 2... so we just check 
                whether I is multiples of 2 or not... =)</font></p><h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="681 - Convex Hull Finding">681 - 
                        Convex Hull Finding</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">As the name suggests... Your task is 
                "simply" find the convex hull... You can't solve this problem unless you 
                have learned at least one of convex hull finding algorithm (Graham Scan,&nbsp; 
                Jarvis March/Gift Wrapping, Divide &amp; Conquer, Quick hull, etc). Knowing 
                the algorithms is also insufficient since it is very hard (at least for 
                me) to produce a 100% bug-free code... This problem will be a perfect 
                testing ground for those who want to try learning computational geometry 
                :). Try it.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="686 - Goldbach's Conjecture (II)">
                        <font face="Verdana" size="2">686 - Goldbach's Conjecture (II)</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">4 until 2^15 is small :-), prepare 
                a pre-calculated primes below 2^15. Then for a given n, just 
                find pairs of primes (from prime table) so that the total of 
                this two primes equal to n.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="694 - The Collatz Sequence">
                        694 - The Collatz Sequence</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">3n+1 again. It shouldn't be 
                difficult, isn't it? Just simulate it, counting the 
                maximum terms computed.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="696 - How Many Knights">696 - How Many Knights</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">There exist a formula to count number of 
                possible placement of knight in M*N board without backtracking at all. You 
                must derive this formula since 500*500 is too big for simulation. </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="699 - The Falling Leaves">699 - The Falling Leaves</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Given a tree with values in the nodes. 
                Flatten them (i.e. put all nodes on the ground), summing their values. And 
                then print from left to right. The key algorithm to solve this problem is 
                your Tree Traversal algorithm.</font>

            </p>





        </div>
    </div>
</div>
