<div data-page="11200" class="page">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="left"><a href="index.html" class="back link icon-only"><i class="icon icon-back"></i></a></div>
            <div class="center">Volume 112 (11200-11299)</div>
        </div>
    </div>

    <div class="page-content">
        <div class="content-block">




            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b>
                    <font face="Verdana" size="2">
                    <a name="11201_-_The_problem_of_the_crazy_linguist">11201 - The problem of 
                        the crazy linguist</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">The idea is to permute and precompute the average of SBC of the words starts 
                with letter X with size N. Thus, we have a table of PRE[X][N].
                Then, for every string inputs, you need to compute the SBC value of the 
                corresponding input and compare it with the Pre-computed table.<br>
                <br>
                <b><a name="11202_-_The_least_possible_effort">11202 - The least possible 
                        effort</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">There are 2 cases that we must consider:<br>
                1. the board is a square of size N<br>
                - There always be Floor(N/2) sets of 4-symmetrical unit squares<br>
                - If the side are ODD, there exist another Floor(N/2) sets of 4-symmetrical 
                unit squares<br>
                - The rest of the area should be sets of 8-symmetrical unit squares<br>
                2. the board is NOT a square<br>
                - If the side are ODD, there exist Floor(N/2) sets of 2-symmetrical unit 
                squares<br>
                - The rest of the area should be sets of 4-symmetrical unit squares<br>
                <br>
                <b><a name="11203_-_Can_you_decide_it_for_ME">11203 - Can you decide it for 
                        ME?</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">From the complex definition of theorem, it actually can be reduced to:<br>
                Let s = the string that we input<br>
                1. M = s.find_first_of('M'); E = s.find_first_of('E')<br>
                2. If 'M' or 'E' is not found or M &gt; E, it is not a theorem.<br>
                3. s1 = substring of s from index (0, M-1); s2 = substring of s from 
                index(M+1, E-1); s3 = substring of s from index(E+1) onwards;<br>
                4. if s1, s2 and s3 only contains '?' AND s1.size() + s2.size() == s3.size() 
                then it is a theorem. Otherwise, it is not a theorem.<br>
                <br>
                <b><a name="11204_-_Musical_instruments">11204 - Musical instruments</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">To solve this problem, a table of INST[idx]. The content of INST[idx] 
                indicates the number of students whose favorite is instrument No. (idx)
                e.g. INST[1] = 2, means there are 2 students whose favorite is instrument 
                No. 1<br>
                From the permutation formula, the number of possible arrangement is:<br>
                Let N = number of musical instruments<br>
                Let total = number of possible arrangement<br>
                <br>
                total = 1<br>
                for i = 1 to N<br>
                if not INST[i] = 0 then total = total * INST[i]<br>
                next<br>
                return total<br>
                <br>
                <b><a name="11207_-_The_easiest_way">11207 - The easiest way</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">There are 2 possible arrangements for maximum size of 4-squares for a given 
                size of paper<br>
                X X<br>
                X X<br>
                <br>
                AND<br>
                <br>
                X X X X<br>
                <br>
                Thus, we get the formula:<br>
                let l = longer side of the rectangular paper<br>
                let s = shorter side of the rectangular paper<br>
                max square size = MAX(MIN(l/4.0, s), s/2.0)<br>
                <br>
                Iterate through the answer and search for the first maximum.<br>
                <br>
                <b><a name="11218_-_KTV">11218 - KTV</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">For this problem, dynamic programming technique is used. Bit manipulation is 
                used for storing all the possible positions for all 9 people.<br>
                Let PJ[X] indicates the maximum score for the X position. X position can be 
                break down to 9 bits. Every bit indicate whether the corresponding people 
                has been picked up.<br>
                e.g. PJ[0] = 0, corresponds to 000000000 (no person have been picked up as a 
                group) has the maximal score of 0<br>
                PJ[511] = 100, corresponds to 111111111 (all person have been picked up as a 
                group) has the maximal score of 100<br>
                <br>
                PJ[511] (111111111) can be filled by combining the previous memorized state.<br>
                i.e. = MAX(PJ 111111000 + GROUP 000000111, PJ 111110100 + GROUP 000001011, 
                etc)<br>
                <br>
                The answer will be stored in PJ[511]<br>
                <br>
                <b><a name="11219_-_How_old_are_you">11219 - How old are you?</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">Let cdate, cmonth, cyear = current date month and year respectively<br>
                Let bdate, bmonth, byear = birthday date month and year respectively<br>
                <br>
                The formula is:<br>
                age = byear - cyear<br>
                if cmonth &lt; bmonth OR (cmonth = bmonth AND cdate &lt; bdate) age = age - 1<br>
                <br>
                <b><a name="11220_-_Decoding_the_message.">11220 - Decoding the message.</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">Quite straight forward, just follow the instructions of the problem.<br>
                <br>
                <b><a name="11221_-_Magic_square_palindromes.">11221 - Magic square 
                        palindromes.</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">The steps:<br>
                - First, the string must be filtered out from all non-alpha characters.<br>
                - Second, if the string size is not a perfect square, it is not a magic 
                palindrome<br>
                - Third, the string must be reversed by this formula:<br>
                let s = the filtered string<br>
                let inv = the reversed string<br>
                let side = Floor(sqrt(s.size()))<br>
                <br>
                for i = 0 to side-1<br>
                for j = 0 to side-1<br>
                inv = inv + s[j*side+i]]<br>
                next<br>
                next<br>
                - Fourth, the reversed string must be the same as the original string and 
                both of them must be palindrome. Otherwise, it is not a magic palindrome.<br>
                <br>
                <b><a name="11222_-_Only_I_did_it!">11222 - Only I did it!</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">Array of size 10000 (let it be SOL) can be used to store the number of times 
                a particular problem has been solved and who solved it.<br>
                Count up all the 1s in the SOL array and print out as necessary.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="11223_-_O:_dah_dah_dah!">11223 - 
                        O: dah dah dah!</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">A pure simulation and coding problem. Try to 
                put the morse code into STL map for easier implementation.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="11225_-_Tarot_Scores.">11225 - 
                        Tarot Scores.</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">Ad-hoc problem with some string manipulation. 
                Use STL Map to help implementing the string manipulation (e.g. MAP["one"] = 
                1, etc).</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2"><b><a name="11226_-_Reaching_the_fix-point.">
                        11226 - Reaching the fix-point.</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">To solve this problem, first pre-calculate the 
                prime numbers from 2 to 500000. After getting the prime numbers, using 
                backtrack generate all the Sum of Prime Factors for all the numbers. After 
                getting the table of Sum of Prime Factors for every numbers, getting the 
                value of lsof can be done linearly with reading the input.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="11227_-_The_silver_bullet.">11227 
                        - The silver bullet.</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">This problem can be solved by pure brute-force 
                technique with complexity of O(N^3). Some tricks that can help in 
                implementing the solution:<br>
                - Make the 2-decimal digit floating point into integer by multiplying it to 
                100<br>
                - Be careful with the floating precision point when reading the input, when 
                the input is +ve add +ve epsilon (e.g. 1e-10), when the input is -ve add -ve 
                epsilon (e.g. -1e-10).<br>
                - vector cross product can be used easily to check the alignment (observe 
                that cross product will be 0 for aligned vector).<br>
                <br>
                <b><a name="11231_-_Black_and_white_painting">11231 - Black and white 
                        painting</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">After some observation, a formula can be 
                derived to get the answer in O(1) time.<br>
                Let A = (R-8+1)*(C-8+1), where R and C are rows and cols respectively.<br>
                P(R,C,W) = (A/2) + (A % 2)*W<br>
                Beware of the limit of signed integer.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="11233_-_Deli_Deli">11233 - Deli 
                        Deli</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">A simulation problem. Trace all the words and 
                do as what the requirements have stated. map&lt;string, string&gt; can be used to 
                help on getting the irregular plural words.<br>
                <br>
                <b><a name="11239_-_Open_Source">11239 - Open Source</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">String processing and sorting problem. 
                Implementation-wise, try to get the unique student ids for every single 
                project. While doing that, a blacklist table consisting of students that 
                registered for more than one project is filled. Later, based on the unique 
                student ids for each project and the blacklist table the answer can be 
                derived.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="11241_-_Humidex">11241 - Humidex</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">With some algebra, the formula for getting 
                dewpoint from h can be derived.<br>
                DEW(h) (1/(1/273.16 - log((h/0.5555 + 10.0)/6.11)/5417.7530)-273.16), where 
                log is the natural logarithm.<br>
                After that, the rest of the problem is quite simple.<br>
                <br>
                <b><a name="11244_-_Counting_Stars">11244 - Counting Stars</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">Ad-hoc problem. Trace through the map of the 
                stars and check the surrounding to determine whether a '*' is a star. We can 
                use flood fill algorithm for this.<br>
                <b><br>
                    <a name="11247_-_Income_Tax">11247 - Income Tax</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">Math problem. By some observation, it can be 
                derived that:<br>
                v &lt; (M-1)*100/(100-X).<br>
                Tricky cases: beware of the upper limit, int32 limit (use long long), M=1, 
                X=0, X=100</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="11254_-_Consecutive_Integers">
                        11254 - Consecutive Integers</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">Using the formula for summation of an 
                arithmetic progression, 2T = 2na + n^2 - n, we need to find maximum n. From 
                this formula, we can see the maximum possible value of n is sqrt(2T). Since 
                T is given, we only need to try all values of n to get a value for a. The 
                value for a is valid if (2T + n - n^2) is divisible by 2n and is not 
                negative. We can then know that a is the starting value in the progression 
                and n is the number of items in the progression.<br>
                <br>
                <b><a name="11258_-_String_Partition">11258 - String Partition</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">This problem is a dynamic programming problem. 
                A scanned number is not a 32-bit integer if it has a length greater than 10 
                or it is greater than INT_MAX (use long long). For a given, substring, split 
                the substring in such a way that there are at most 10 digits on the left. 
                Use the precalculated value to find the maximal value on the right. Find the 
                maximum of all these sums and that is the answer. 2-dimensional DP will time 
                out.<br>
                <br>
                <b><a name="11262_-_Weird_Fence">11262 - Weird Fence</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">This is a bipartite matching question combined 
                with binary search. Basically we want to search for the minimum integer 
                length of the chains so as to form at least k matchings. Therefore, for 
                every midpoint in the binary search, form a graph such that every red pole 
                is joined to a blue pole if their distance is less than or equal to the 
                midpoint. From there, carry on the bipartite matching. If such a length 
                cannot be found, print Impossible.<br>
                <br>
                <b><a name="11264_-_Coin_Collector">11264 - Coin Collector</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">This is quite a difficult greedy problem 
                because it depends on the person attempting it to spot the pattern. counter 
                is set to n. Start with the total equaling the first coin. Then start the 
                loop from the second coin onwards. If the sum of the total and the current 
                coin value exceeds or equals the value of the coin right after the current 
                coin, the current coin's value is not taken into the total and counter is 
                decremented by one. Output counter at the end of the loop.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2"><b>
                    <a name="11267_-_The_Hire-a-Coder_Business_Model">11267 - The Hire-a-Coder 
                        Business Model</a></b><br>
                <br>
                This problem tests on bipartite testing and MST. Firstly, after reading in 
                all the edges, test if the graph is bipartite to ensure that the data is 
                valid. If the graph is not bipartite, exit with the "Invalid data, Idiot!". 
                Otherwise, continue on with Kruskal. However, there is a twist. Since there 
                are negative edges and the company wants to minimize loss, the program must 
                also pick edges that are not in the MST but are negative so that the total 
                sum of loss is as little as possible.<br>
                <br>
                <b><a name="11269_-_Setting_Problems">11269 - Setting Problems</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">This is a greedy problem though there is a 
                known algorithm for it called the Johnson's scheduling algorithm. Basically 
                partition the tasks into two. Those with s &lt;= g put into list 1 and those 
                with s &gt; g put into list 2. Sort list 1 in ascending values of S and sort 
                list 2 in descending values of G. Then add up all the S values together to a 
                total. For the G values, it is slightly more complicated. If a G value is 
                greater than the S value of the task after it, then add the difference to 
                the G of the task that comes after it.<br>
                <br>
                <b><a name="11270_-_Tiling_Dominoes">11270 - Tiling Dominoes</a></b><br>
                <br>
                This problem seems like a difficult problem at first sight. However, there 
                is a closed form to the possibly recursive solution that is needed. The 
                formula is found at
                <a target="_blank" href="http://en.wikipedia.org/wiki/Domino_tiling">
                    http://en.wikipedia.org/wiki/Domino_tiling</a>. However, because there are 
                roots and PI involved, care has to be taken when handling the long doubles. 
                For some cases, the number 0 is actually computed as a very small number and 
                not as 0 itself. To handle such cases, ensure that if a number is smaller 
                than a certain precision required by the program, the number is actually 
                representing zero.<br>
                <br>
                <b><a name="11275_-_3D_Triangles">11275 - 3D Triangles</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">This question is quite crazy. Many algorithms 
                from MÃ¶ller to Held to even Guigue were tried but they all took more than 2 
                seconds and TLEd. Only the algorithm from Hao Shen, Pheng Ann Heng and 
                Zesheng Tang worked and was the only one which took less than a second to 
                complete. Amazing stuff. Who knew that calculating the intersection of two 
                triangles in 3D space would take so much work. Here is an <br>
                implementation of the algorithm:
                <a target="_blank" href="http://jgt.akpeters.com/papers/ShenHengTang03">http://jgt.akpeters.com/papers/ShenHengTang03</a></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2"><b><a name="11278_-_One-Handed_Typist">11278 - 
                        One-Handed Typist</a></b><br>
                <br>
                This problem is a simple linear search problem. Simply place the matching 
                keys of the QWERTY and DVORAK keyboards in the same position inside their 
                respective strings. Once done, a linear search is done for every key read in 
                the input and the DVORAK character from the position of the QWERTY key found 
                is output instead resulting in a mapping between the QWERTY and DVORAK 
                keyboards.<br>
                <br>
                <b><a name="11279_-_Keyboard_Comparison">11279 - Keyboard Comparison</a></b><br>
                <br>
                This is a simulation/math problem. Firstly, all keys must be mapped to a 
                coordinate. If the x, y coordinates start from the bottom left, then for 
                example, the key z on the QWERTY keyboard will have the coordinate (1.5, 
                0.5). Using this information, the coordinates of the respective home keys 
                must then be stored in arrays. From there, for every statement read in, 
                every character of the statement must have its distance between every home 
                key calculated and the shortest distance found will be added to the total. 
                The formula used for calculating distance is the math formula for 
                calculating distances between two Cartesian points i.e. sqrt ((x1 - x2)^2 + 
                (y1 - y2)^2).</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="11280_-_Flying_to_Fredericton">
                        11280 - Flying to Fredericton</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">This is a special case of Bellman-Ford. Take 
                note that the same set of edges can be produced as input twice. Thus, if the 
                same set of edges is encountered again, take the set with the lowest cost 
                amongst them. For the modification of Bellman-Ford, take note that when 
                Bellman-Ford is run |V| - 1 times, it is actually finding the shortest path 
                in which the shortest path consists of at most |V| - 1 edges. Therefore, for 
                this problem, Bellman-Ford has to be run numberOfStops + 1 times to retrieve 
                the answer.<br>
                <br>
                <b><a name="11281_-_Triangular_Pegs_in_Round_Holes">11281 - Triangular Pegs 
                        in Round Holes</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">For this problem, what is needed is the 
                minimum bounding circle for all the triangles given as input. There is a 
                formula to find the diameter of the minimum bounding circle which is (2.0 * 
                abc) / sqrt((a + b + c) * (b - a + c) * (a - b + c) * (a + b - c)) where a b 
                and c are the lengths of the sides of the triangle. However, this formula 
                does not apply to obtuse triangles. For obtuse triangles, the diameter of 
                their<br>
                minimum bounding circle is the length of the longest side in the triangle. 
                For such a case, use Pythagoras' theorem which states that a^2 + b^2 &lt; 
                hypotenuse^2 is true when the triangle is obtuse. If so, use the 
                hypotenuse's length as the length of the minimum bounding circle. Also take 
                care to allow for errors up to 1e-6 since floating point numbers are used.<br>
                <br>
                <b><a name="11282_-_Mixing_Invitations">11282 - Mixing Invitations</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">This problem falls under derangements in the 
                field of combinatorics. There is a formula to find a derangement for a given 
                N. That value represents the number of ways of mixing up everyone in that 
                whole set such that no one gets the right card. So, to get the number of 
                ways for everyone but EXACTLY k people to get the wrong card, we use the 
                corollary, (N choose k) * D[N - k] where D is the array of derangements.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2"><b><a name="11283_-_Playing_Boggle">11283 - 
                        Playing Boggle</a></b><br>
                <br>
                This is a problem concerning DFS. Basically for every word that is given as 
                input, a DFS must be done to search the Boggle grid whether that word exists 
                in the grid. If the DFS returns with the word found, then the score for that 
                word is added to the total score. At the end, the total score is sent to 
                output.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2"><b><a name="11286_-_Conformity">11286 - 
                        Conformity</a></b><br>
                <br>
                This problem first requires a sort of each row of course data given. The 
                solution then requires that this sorted data be the key in a map. However, 
                since the data is in the form of an integer array, what needs to be done is 
                to convert this data into a number. As there are only 400 represent-able 
                values for each position (plus an additional 0 to represent courses that are 
                not chosen), the base of the system should be 401. Thus, after the sort, the 
                new number's value can be easily calculated and mapped as a key. Using the 
                map, it can then be determined which choices occur most frequently. 
                Whichever choices occur at the same maximum frequency will have the student 
                counts for those choices added into the final total.<br>
                <br>
                <b><a name="11287_-_Pseudoprime_Numbers">11287 - Pseudoprime Numbers</a></b><br>
                <br>
                This question basically requires primality testing and an application of 
                Fermat's little theorem. A little knowledge of modular arithmetic is needed. 
                Basically (a*a) mod p = ((a mod p) * (a mod p)) mod p. Thus, for every 
                number in the input. First test if it's prime (this can be done by dividing 
                by all the numbers smaller than its square root). If it is prime, then the 
                answer is automatically no. Otherwise, apply Fermat's little theorem on it. 
                If it is successful, the input number is a pseudoprime and yes has to be 
                output.<br>
                <br>
                <b><a name="11289_-_Friend_or_Foe">11289 - Friend or Foe?</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">This is a gradient descent/ascent search 
                problem. We start with a random possible solution. Then, we progress the 
                search by comparing with every system given. For all alliance systems, we 
                want to minimize f(x) so that the inequality holds false. Thus for every 
                alliance system to which the current solution set makes the equality hold 
                true, we move the solution by the negative gradient of that alliance system. 
                The opposite is done for all empire systems. Stop when the solution set is 
                not modified anymore.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2"><b><a name="11291_-_Smeech">11291 - Smeech</a></b><br>
                <br>
                This problem requires recursion to be done. The function recurse() will 
                return the value of the Smeech expression read in. Inside recurse, all 
                whitespaces are first eliminated. Then the input is tested to see if the 
                next character is part of a number or part of an 'inner' Smeech expression. 
                If it is a number, the number is just read in and returned. Otherwise, the 
                opening bracket of the Smeech expression is consumed and the p in the 
                expression is read in. For the e1 and e2 values, recurse() will be called to 
                handle them as they can themselves be either integers or inner Smeech 
                expressions. After that, calculations are done and returned to the caller.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2"><b><a name="11292_-_Dragon_of_Loowater">11292 
                        - Dragon of Loowater</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">This is a simple greedy problem. Sort the 
                diameter of the heads in descending order while the heights of the knights 
                are sorted in ascending order. For every dragon head, find the smallest 
                knight height that just meets the diameter of the dragon head and make sure 
                not to reuse this knight once he's taken.<br>
                <br>
                <b><a name="11296_-_Counting_Solutions_to_an_Integral_Equation">11296 - 
                        Counting Solutions to an Integral Equation</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font face="Verdana" size="2">The hint comes from the equation. When 
                rearranged, it becomes x = n - 2(y + z). Since n is given and 2(y + z) must 
                always be even, then there are only two cases to consider, namely when n is 
                odd or even. If n is odd, then x can only take on odd values. If n is even, 
                then x can only take on even values. How to count the number of y,z pairs? 
                For any integer k = 2(y + z), there are always k/2 + 1 such pairs.
                [an error occurred while processing this directive]</font></p>



        </div>
    </div>
</div>
