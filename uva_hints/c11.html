<div data-page="11100" class="page">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="left"><a href="index.html" class="back link icon-only"><i class="icon icon-back"></i></a></div>
            <div class="center">Volume 111 (11100-11199)</div>
        </div>
    </div>

    <div class="page-content">
        <div class="content-block">




            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <a name="11101_-_Mall_Mania"><b><font size="2">11101 - </font></b><b>
                        <font size="2">Mall Mania</font></b></a></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">My solution is not correct actually, but it was accepted by 
                the judge. This problem require the shortest distance between two sets of 
                points. O(n^2) algorithm will get TLE, so I randomly pick 1000000 pair of 
                points and find the shortest distance among them. The data is not strong 
                enough and this get accepted. </font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11103_-_WFF_N_PROOF">11103 - WFF 'N PROOF</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a string processing problem. There are three kinds of 
                characters: the literal, operator with one argument, and operator with two 
                arguments. First, since "if w is a WFF, Nw is a WFF", we can add all 'N' 
                before one literal. Then, try to make full use of 'K','A','C','E', if any, 
                to form longer WFF. If the number of literals is 0, it is impossible to form 
                any WFF. So output "no WFF possible".</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11105_-_Semi-prime_H-numbers">11105 - Semi-prime 
                        H-numbers</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a math problem. First, use the idea of sieve to find 
                all the H-primes. Then, find all H-sem-prime by enumerating all pair of 
                H-primes less than or equal to 1,000,001. Since all H-numbers are in the 
                form of 4*n+1, so we can simply use integer n to represent a H-number. The 
                answer is the number of H-semi-primes less than or equal to n.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11107_-_Life_Forms">11107 - Life Forms</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a string processing problem. First build suffix array 
                for all substrings of each string. Then find all minimum intervals in the 
                suffix array which contains at least substring of more than half of the 
                original strings, and find the longest prefix of two end of each intervals. 
                The longest prefix of all intervals is the result. stable_sort (merge sort) 
                runs faster when comparison is expensive (string comparison).</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11108_-_Tautology">11108 - Tautology</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a math problem. There are at most 5 Boolean 
                variables. So just use brute force to enumerate all possible truth table and 
                evaluate the expression. If we get a false as the result of the expression 
                for some truth table, then it is not a Tautology.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11110_-_Equidivisions">11110 - Equidivisions</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a flood fill problem. The only tricky part is the 
                input may not necessarily be n pair each line.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11115_-_Uncle_Jack">11115 - Uncle Jack</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a math problem. The result is obviously n^d. 10^25 is 
                larger than the maximun value of long long, so use big integer to calculate 
                and store the result.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11121_-_Base_-2">11121 - Base -2</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a math problem. If the number is an odd number, then 
                b0 must be 1, else b0 is 0. If we know the value of b0, reduce the original 
                number by b0, and devide by -2, then the base -2 representation of the new 
                number will be b1+(-2)*b2+... <br>
                To find b1,b2.. is a subproblem of the original problem.<br>
                The base case is when the number is 1, the result is 1; when the number is 
                0, the result is 0..</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11122_-_Tri_Tri">11122 - Tri Tri</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a computational geometric problem. Two triangles have 
                common internal point if and only if there exist one edge in on triangle 
                which can separate this triangle from the other one.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11129_-_An_antiarithmetic_permutation">11129 - An 
                        antiarithmetic permutation</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is an ad hoc problem. Notice that if the first half of 
                an array are even numbers, the second half of an array are odd numbers, then 
                no arithmetic progression containing both odd and even elements will be 
                found because (even even odd) and (even odd odd) are impossible to be 
                arithmetic progression. Then the problem becomes to find a permutation of 
                all odd(even) elements smaller than n which contains no subsequence which is 
                arithmetic progression. If we devide all elements of the odd(even) 
                permutation by 2, we will get an antiarithmetic permutation, which is a 
                subproblem. So this problem can be solved using divide and conquer. The 
                total complexity should be O(n log n).</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11130_-_Billiard_bounces">11130 - Billiard 
                        bounces</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a math (physics?) problem. First, find the distance 
                the ball can go if there is no boundary. Then, according to the symmetric 
                property of the moving path, we can consider that the ball is moving in a 
                segment in a plain with a*b grids. The result is the number of times the 
                segment intersect with vertical lines and horizontal lines.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11133_-_Eigensequence">11133 - Eigensequence</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a math and DP problem.<br>
                If an array is eigensequence, then a[n]%(a[n]-a[n-1])==0, <br>
                so a[n]=k*(a[n]-a[n-1]) for some integer k.<br>
                so a[n]-(a[n]-a[n-1])=a[n-1]=(k-1)*(a[n]-a[n-1])<br>
                so a[n-1]%(a[n]-a[n-1])==0.<br>
                In fact, for any integer b, if a[n-1]%b == 0, a[n-1]+b is a valid choice for 
                a[n].(because a[n]%b==0).<br>
                For any interval [x,y], use f[x][y] to denote the number of eigensequence 
                start with x and end with y.<br>
                f[x][y]=sum(f[x+i][y]) for all i which a%i==0 and a+i&lt;b.<br>
                boundery cases: if x == y, f[x][y]=1;<br>
                if x &gt; y, f[x][y]=0;</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11137_-_Ingenuous_Cubrency">11137 - Ingenuous 
                        Cubrency</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is coin change problem. Use long long to store answer, 
                and memoization to perform DP.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11138_-_Nuts_and_Bolts">11138 - Nuts and Bolts</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a max matching problem. First read Jimmy's code. 
                Jimmy is trying to use back tracking to solve a max matching problem. Just 
                use code of Hungary algorithm to replace his match_bolt function will do.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11149_-_Power_of_Matrix">11149 - Power of Matrix</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a matrix multiplication problem.<br>
                To calculate <br>
                A + A^2 + A^3 + .. + A^k<br>
                If k is even, <br>
                then the result equals<br>
                A + A^2 + A^3 + .. + A^(k/2)<br>
                +<br>
                A^(k/2)*(A + A^2 + A^3 + .. + A^(k/2))<br>
                If k is odd<br>
                then the result equals<br>
                A + A*(<br>
                A + A^2 + A^3 + .. + A^(k/2)<br>
                +<br>
                A^(k/2)*(A + A^2 + A^3 + .. + A^(k/2))<br>
                )<br>
                <br>
                The complexity is O(n^3 * log k).</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11150_-_Cola">11150 - Cola</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">In problem 11150, note that bottles borrowing can be done at 
                any time without changing the result of the problem. Thus, to solve the 
                problem, just simulate the normal method given in the problem statement. If 
                there are two empty bottles left at the end of the simulation, then one more 
                bottle can be borrowed to maximize the number of bottles enjoyed.<br>
                <br>
                <b><a name="11151_-_Longest_Palindrome">11151 - Longest Palindrome</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">Problem 11151 can be solved by using dynamic programming. Let 
                longest[i][j] be the longest palindrome extracted from the substring s[i..j] 
                of s. The answer for the problem will be longest[0][strlen(s)-1]. The values 
                of longest[i][j] can be calculated as follows:<br>
                If i &gt; j then longest[i][j] = 0<br>
                If i = j then longest[i][j] = 1<br>
                If i &lt; j and s[i] = s[j] then longest[i][j] = 2 + longest[i+1][j-1]<br>
                If i &lt; j and s[i] != s[j] then longest[i][j] = max(longest[i+1][j], 
                longest[i][j-1])<br>
                <br>
                <b><a name="11152_-_Colourful_Flowers">11152 - Colourful Flowers</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">Problem 11152 is a simple geometry problem. In this problem, 
                use the following formulas:<br>
                p = (a+b+c)/2;<br>
                S = sqrt(p*(p-a)*(p-b)*(p-c));<br>
                R = (a*b*c)/(4*S);<br>
                r = S/p;<br>
                S_red = (PI*r*r);<br>
                S_blue = S-S_red;<br>
                S_yellow = (PI*R*R)-S;<br>
                <br>
                <b><a name="11155_-_Be_Efficient">11155 - Be Efficient</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">For this problem, note that the same answer can be obtained 
                if the sequence is changed to:<br>
                X0 = A%M<br>
                Xi = ((((Xi-1)*B+C)%M)+1)%M<br>
                With the new sequence, process the elements in order X0, X1, ..., Xn-1. At 
                iteration for Xi, maintain a number "base" and an array 
                "numRemainder[0..M-1]" such that numRemainder[(base+i)%M] is the number of 
                consecutive subsequences whose last element is Xi and whose sum divided by M 
                give the remainder i. The value of "base" and "numRemainder" can be updated 
                efficiently at each iteration.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><a name="11157_-_Dynamic_Frog"><font size="2">11157 - Dynamic Frog</font></a></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">The problem can be solved by a simple greedy algorithm. If 
                the current rock is i, then check the rock i+1. It rock i+1 is big, then 
                land on it. If rock i+1 is small, then land on rock i+2. Start at the left 
                bank and repeat the process until reaching the right bank. Then return back 
                to the left bank using the remaining rocks.<br>
                <br>
                </font><b><a name="11158_-_Elegant_Permuted_Sum"><font size="2">11158 - 
                        Elegant Permuted Sum</font></a></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This problem can be solved by using a greedy algorithm. 
                First, sort the array and make a new list of two elements: the smallest and 
                the largest integers from the sorted array. Then, in each step, greedily 
                choose the best among the following 4 cases: (1) put the smallest element of 
                the remaining sorted array to the beginning of the new list, (2) put the 
                smallest element of the remaining sorted array to the end of the new list, 
                (3) put
                the largest element of the remaining sorted array to the beginning of the 
                new list, and (4) put the largest element of the remaining sorted array to 
                the end of the new list.<br>
                <br>
                </font><b><a name="11159_-_Factors_and_Multiples"><font size="2">11159 - 
                        Factors and Multiples</font></a></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">For this problem, build a bipartite graph between set A and 
                set B where there is an edge between i (in A) and j (in B) if i|j. Then, the 
                question will be equivalent to finding the maximum matching in this 
                bipartite graph. Use Ford Fulkerson/Edmonds Karp algorithm to solve this 
                problem.<br>
                <br>
                </font><b><a name="11160_-_Going_Together"><font size="2">11160 - Going 
                        Together</font></a></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This problem can be solved by using BFS algorithm. Let a 
                state be a triple of the positions of A, B, and C in the maze. Use BFS to 
                search whether there is a path from the initial state to a final state. A 
                final state is a state where A, B, and C are on three target cells.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2"><b><a name="11161_-_Help_My_Brother_(II)">11161 - Help My 
                        Brother (II)</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">Problem 11161 is about Fibonacci sequence and big integer 
                arithmetic. Let f(n) be the n-th Fibonacci number and m(k) be the median of 
                the k-th line. The problem can be solved by using the formula m(k) = 
                (f(k+3)-3)/2.<br>
                <br>
                </font><b><a name="11164_-_Kingdom_Division"><font size="2">11164 - Kingdom 
                        Division</font></a></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">Let d1 be the area of triangle XEF and d2 be the area of 
                triangle AEF. Then d1 and d2 can be calculated from the following equations: 
                d1/a = c/b and (a+d1)/d2 = (a+b)/(c+d1+d2). The result will be d = d1+d2.<br>
                <br>
                </font><b><a name="11166_-_Power_Signs"><font size="2">11166 - Power Signs</font></a></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">Note that 0++ = +0-, 0+++ = +00-, 0++++ = +000-, 0+++++ = 
                +0000-, ... <br>
                So, the problem can be solved by the following greedy algorithm: process the 
                input from right to left, replace all the 011...110 subsequences with 
                +00..0-0, except for the left most 11.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11170_-_Cos(NA)">11170 - Cos(NA)</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">Problem 11170 just asks to calculate cos(nA) as a polynomial 
                of cos(A) (note that the coefficients of the polynomial may be larger than 
                32 bits). To calculate cos(nA), use the polynomial arithmetic and the 
                following recursive formula: cos(nA) = 2*cosA*cos((n-1)A) - cos((n-2)A) for 
                n &gt;= 2.<br>
                <br>
                <b><a name="11172_-_Relational_Operator">11172 - Relational Operator</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">Problem 11172 is a simple problem about relational operators. 
                Given two numbers a and b, print out: <br>
                "&lt;" if a &lt; b<br>
                "=" if a = b<br>
                "&gt;" if a &gt; b<br>
                <br>
                <b><a name="11173_-_Grey_Codes">11173 - Grey Codes</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">For problem 11173, let f(n,k) be the integer that appears in 
                position k of the n-bit Reflected Gray Code (0 &lt;= k &lt; 2^n). The value of 
                f(n,k) can be computed by using the following recursive formulas:<br>
                For n = 1: f(1,k) = k<br>
                For n &gt; 1:<br>
                If k &lt; 2^(n-1) then f(n,k) = f(n-1,k)<br>
                If k &gt;= 2^(n-1) then f(n,k) = 2^(n-1) + f(n-1, 2^n-k-1)<br>
                <br>
                </font><b><a name="11176_-_Winning_Streak"><font size="2">11176 - Winning 
                        Streak</font></a></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">This is a dynamic programming problem. Let P[i][j] be the 
                probability of having at most j consecutive wins in i consecutive games. The 
                probability of having a winning streak of length k is P[N][k] - P[N][k-1]. 
                To calculate P[i][j], consider the following cases:<br>
                P[i][j] = 1 for all 0 &lt;= i, j &lt;= N and j &gt;= i<br>
                P[i][i-1] = 1-p^i for all 1 &lt;= i &lt;= N<br>
                P[i][j] = P[i-1][j]-p^{j+1}*(1-p)*P[i-2-j][j] if 2 &lt;= i &lt;= N, 0 &lt;= j &lt;= i-2<br>
                <br>
                </font><b><a name="11180_-_Base_i-1"><font size="2">11180 - Base i-1</font></a></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">In this question, note that 2 = (i-1)^2 + (i-1)^3. First, 
                rewrite a+bi = (a+b) + b(i-1).<br>
                If a+b &gt; 1 or a+b &lt; 0, then using the above formula to propagate the 
                coefficient to (i-1)^2 and (i-1)^3. Then, continue with the coefficient of 
                (i-1) and propagate to (i-1)^3 and (i-1)^4. Just be careful with the 
                termination condition for this process.<br>
                <br>
                </font><b><a name="11181_-_Probability|Given"><font size="2">11181 - 
                        Probability|Given</font></a></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">Note that P(X|Y) = P(XY)/P(Y). So, for each person i, 
                calculate the probability Pi of the event that person i buys and there are 
                other r-1 buyers. Also, calculate the probability P that there are exactly r 
                buyers among the N persons. The result for each person i will be Pi/P. To 
                calculate the probabilities, use a complete search to find all the subsets 
                that have exactly r elements.<br>
                <br>
                </font><b><a name="11184_-_Joyful_Ride"><font size="2">11184 - Joyful Ride</font></a></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">In this problem, if N%4=1 or N%4=2, then there is no 
                solution. If N%4=0 or N%4=3, use the following greedy algorithm: let A[0] = 
                1 and A[1] = N+1, the difference height between them is N. Now put the 
                heights into A[2], A[3], ... such that the difference heights are N-1, N-2, 
                ..., N/2+1, N/2-1, ..., 2, 1, N/2 respectively. Note that the array A must 
                satisfy the property (A[i]-A[i-1])(A[i]-A[i+1]) &gt; 0.</font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <b><font size="2"><a name="11185_-_Ternary">11185 - Ternary</a></font></b></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">Problem 11185 is a simple problem about ternary. To solve the 
                problem, use the standard algorithm to convert a decimal number into ternary 
                and print out the result.<br>
                <br>
                <b><a name="11192_-_Group_Reverse">11192 - Group Reverse</a></b></font></p>
            <p style="margin-left: 20; margin-right: 20" dir="ltr" align="left">
                <font size="2">Problem 11192 is a simple problem about strings. For each 
                group in the given string, reverse the group by swapping the first and the 
                last characters, the second and the second to last characters, etc. Then, 
                print out the final string.</font><br>
                <font face="Verdana" size="2">
                </font></p>



        </div>
    </div>
</div>
