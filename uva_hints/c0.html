<div data-page="10000" class="page">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="left"><a href="index.html" class="back link icon-only"><i class="icon icon-back"></i></a></div>
            <div class="center">Volume 100 (10000-10099)</div>
        </div>
    </div>

    <div class="page-content">
        <div class="content-block">


            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10000 - Longest Paths">10000 - Longest Paths</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You have to determine the longest 
                path from a given Graph. There is no other way other than exhaustive search.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Build an adjacency matrix (or any 
                other graph representation that you like) and start traversing.
                The simplest one is using Depth First Search (DFS) to traverse all 
                possible paths, and remember the longest paths (and if there are two or more 
                paths with similar longest path, record the SMALLEST END ROUTE !!!).
                After there is no more paths left, output the longest paths.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Take note that you must prune the search tree 
                as soon as possible. I.e. if you have visited a particular node with path 
                length = 5, then if you somehow re-visit this node using another path, but 
                with length = 4... quickly prune and backtrack, since it will be useless. 
                This way, you can avoid Time Limit Exceeded.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="10003 - Cutting Sticks"><font face="Verdana" size="2">
                        10003 - Cutting Sticks</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Exactly similar to matrix-chain 
                multiplication problem (Refer to: Introduction to Algorithms book). Do a complete search through all 
                possible combinations, and apply dynamic programming to it. This 
                problem exploits many repeating sub problems and using DP is compulsory.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10004 - Bicoloring">10004 - Bicoloring</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simply traverse the graph using Breadth First 
                Search, and flip flop the color along the way, i.e. If current node color is 
                "black", then all neighbors of this node (can be reached by one-step BFS) 
                must be colored with "white" and vice versa.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10005 - Packing Polygons">10005 - Packing Polygons</a> (by: Hadi 
                    Moshayedi)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">I consider every pair of points, then I 
                suppose that these two points are on the border of circle. using this, I find 
                the center of the circle. then I calculate the distance of other points from 
                the center. if all points are in distance less than R, a solution has been 
                found, and the polygon can be packed in the circle.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10006 - Carmichael Number">10006 - Carmichael Number</a> (corrected 
                    by: Tommy Lofstedt)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Carmichael numbers are odd numbers which have 
                at least three prime factors, but also, a number is a Carmichael number if 
                and only if it is square-free (that is, it has no repeated prime factors) 
                and for all prime factors p of the number n, p-1 must divide n-1 (that is, 
                p-1|n-1 for all prime factors p of n).<br>
                <br>
                The last two rules are the only ones necessary, but filtering with the first 
                two will make finding the numbers a lot faster.<br>
                <br>
                See these links for more information:<br>
                <a onclick="return top.js.OpenExtLink(window, event, this)" target="_blank" href="http://mathworld.wolfram.com/CarmichaelNumber.html">
                    http://mathworld.wolfram.com<wbr>/CarmichaelNumber.html</a><br>
                <a onclick="return top.js.OpenExtLink(window, event, this)" target="_blank" href="http://en.wikipedia.org/wiki/Carmichael_number">
                    http://en.wikipedia.org/wiki<wbr>/Carmichael_number</a><br>
                </font><br>
                <font face="Verdana" size="2">You can do brute force calculation and then 
                just pre-calculate the output. There are only 15 Carmichael numbers below 
                65000 and those 15 numbers are:
                561, 1105, 1729, 2465, 2821, 6601, 8911, 10585, 15841, 29341, 41041, 46657, 52633, 62745, 
                and 63973.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10007 - Count the Trees">10007 - Count the Trees</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The number of binary tree can be counted using 
                Catalan Number. Here is the efficient way to compute Catalan numbers bottom 
                up using DP.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2"><b>Catalan Number: (2n C n) / (n+1)<br>
                </b><br>
                <b>Catalan(n) =<br>
                </b><br>
                2n!<br>
                ---------------<br>
                n! * n! * (n+1)<br>
                <br>
                <b>Catalan(n+1) =<br>
                </b><br>
                2*(n+1)<br>
                --------------------------- =<br>
                (n+1)! * (n+1)! * ((n+1)+1)<br>
                <br>
                (2n+2) * (2n+1) * 2n!<br>
                ------------------------------- = <br>
                (n+1) * n! * (n+1) * n! * (n+2)<br>
                <br>
                (2n+2) * (2n+1) * 2n!<br>
                ----------------------------------- =<br>
                (n+1) * (n+2) * n! * n! * (n+1)<br>
                <br>
                (2n+2) * (2n+1)<br>
                --------------- * <b>Catalan(n)</b><br>
                (n+1) * (n+2)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">From the pattern above, you can calculate 
                Catalan number bottom up. However in this problem, you must time the result 
                by <b>N!</b> because the trees can be flipped...</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You may be interested to solve problem 10303 
                now :), very very similar</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10008 - Whats Cryptanalysis">10008 - What's Cryptanalysis?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A simple alphabet frequency counting and then 
                output the frequency in descending order... Very easy =)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10009 - All Roads Lead Where">10009 - All Roads Lead Where?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Read the input and convert them into graph 
                representation according to your style. For each pair of cities given, 
                output the shortest distance between them. You can use BFS to solve this 
                problem.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10010 - Wheres Waldorf">10010 - Where's Waldorf?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Read the input into 2 dimensional array. Then 
                check all coordinate (from uppermost+leftmost) and all 8 directions (N,NE,E,SE,S,SW,W,NW) 
                for the desired word.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10012 - How Big Is It">10012 - How Big Is It?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Greedy won't work. You must do exhaustive search. Maximum number of circles 
                is 8. Exhaustive permutation is 8! = 40.320. With pruning it is acceptable. 
                For each ordering, calculate the smallest width by using phytagoras rule.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="10013 - Super long sums"><font face="Verdana" size="2">
                        10013 - Super long sums</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Given two m digits integer, output 
                the sum of them.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Sacrifice memory for this. Declare an array 
                with size 1.000.000.<br>
                When you read the input, add them directly and then store the 
                value to the array.<br>
                After that, normalize the value and output them.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">&nbsp;9&nbsp;&nbsp; 8&nbsp;&nbsp; 7&nbsp;&nbsp; 
                6<br>
                &nbsp;5&nbsp;&nbsp; 3&nbsp;&nbsp; 7&nbsp;&nbsp; 5<br>
                ---------------+<br>
                14&nbsp; 11&nbsp; 14&nbsp; 11</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Step by step normalization<br>
                14&nbsp; 11&nbsp; 15&nbsp;&nbsp; 1<br>
                14&nbsp; 12&nbsp;&nbsp; 5&nbsp;&nbsp; 1<br>
                15&nbsp;&nbsp; 2&nbsp;&nbsp; 5&nbsp;&nbsp; 1</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Result = 15251</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10014 - Simple calculations">10014 - Simple calculations</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">At first, I totally confused until I 
                found solution in the Internet.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This is how to derive the formula:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">a1=(a0+a2)/2-c1<br>
                2a1=a0+a2-2c1<br>
                4a1=2a0+2a2-4c1 ... (1)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">a2=(a1+a3)/2-c2<br>
                2a2=a1+a3-2c2 ... (2)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Combine (1) &amp; (2)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">4a1=2a0+(a1+a3-2c2)-4c1<br>
                3a1=2a0+a3-2(c2+2c1)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">... and so on until n-th term ...<br>
                (n+1)a1=n*a0 + (an+1) - 2(n*c1 + (n-1)*c2 + (n-2)*c3 + ... + 1*cn)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You can calculate a1 from formula 
                above, and don't forget that this problem is in multiple input 
                format.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10015 - Josephs Cousin">10015 - Joseph's Cousin</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This problem is variant of problem 305-Joseph. Now we use prime numbers to 
                count which person to kill... So, pick up your 305 solution, and again 
                simulate the 'killing' process (the circular array stuffs..., you can use 
                linked list but simple array with appropriate shifts after one person killed 
                is enough to pass the time limit), but this time use prime numbers.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">I 
                advise you to pre-generate the first 3501 prime numbers and save this in an 
                array, it will save you a lot of time.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10016 - Flip-flop the Squarelotron">10016 - Flip-flop the 
                        Squarelotron</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                A very very tedious array manipulation problem. Basically what you need to 
                do is to create 2D integer array, and shifting it contents according to the 
                problem description. You need a lot of debugging to solve this problem. 
                Indeed, this is a very good problem to test your array manipulation skill... 
                I'll give you some trick:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Let outermost ring as ring 0 and innermost ring as ring ceil(N/2)<br>
                You can simplify your coding by "forgetting the inner rings" by doing this:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Original:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                aaaa<br>
                bbbb<br>
                cccc<br>
                dddd</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                After UpsideDownFlip(ring 0) =&gt; (actually I flip all from ring 0 and ring 1 
                ...)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                dddd<br>
                cccc<br>
                bbbb<br>
                aaaa</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                I'll fix the mistake by calling UpsideDownFlip(ring 0 + 1 ~ ring 1)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                dddd<br>
                cbbc<br>
                bccb<br>
                aaaa</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This will save you a lot of coding time...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10017 - The Never Ending Towers of Hanoi">10017 - The Never Ending 
                        Towers of Hanoi</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simulate the process of solving Towers of 
                Hanoi problem. A well known problem and there are a lot of websites 
                discussing this Tower of Hanoi problem, please refer to these websites. 
                However, I still find that Towers of Hanoi is a bit complex...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10018 - Reverse and Add">10018 - Reverse and Add</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Just do what they want. They guarantee that the input case will have answer, 
                doesn't need more than 1000 iterations to solve, and will not overflow. 
                These 3 condition simplifies the problem a lot. =)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10019 - Funny Encryption Method">10019 - Funny Encryption Method</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                You don't have to do Xor at all, what they want is from a given input number 
                M, how many '1' this M in binary format (we call this total-&gt;'b1') and how 
                many '1' this M in hexadecimal format (we call this total-&gt;'b2'). Simply 
                convert M to binary and hexa, and then count how many '1' in these two 
                representations of M.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10020 - Minimal coverage">10020 - Minimal coverage</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Greedy solution works, sort the input line segments by Left side first, and 
                if Left side equal, sort by Right side, and then greedily choose the one 
                which Left side &lt;= current left, and Right side is the rightmost (with 
                current left initially set to 0 =&gt; because we want to cover 0..M). After we 
                choose one line segment, we update current left with Right side of this line 
                segment, and repeat the procedure until the Right side of chosen line 
                segment exceeds M (which means we successfully covered 0..M). Print "0" if 
                we cannot find any possible combination to cover O..M.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10023 - Square root">10023 - Square root</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Y can be as big as 10^1000... very big number... I thought of using 
                BigNumber and calculate manually, but the a function 'sqrtl' in math.h is 
                enough to solve this problem... -_-. It's okay anyway :)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                long double Y;<br>
                scanf("%Lf",&amp;Y);<br>
                printf("%.0Lf\n",sqrtl(Y));</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10025 - The  1  2  ...  n = k problem">10025 - The ? 1 ? 2 ? ... ? 
                        n = k problem</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">To simplify the problem:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1. The smallest n that satisfy the 
                formula can only occur if and only if the "?" is not alternating 
                positive/negative =&gt; it's not like this 1+2-3+4-5..., this will 
                make calculation longer.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">2. The value for n will be the same 
                for both k and -k, so don't bother about negative k, just get the 
                absolute value of k to find n.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">3. For the arithmetic series above, 
                the total Sum formula is Sn=n(n+1)/2, we will use this.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Assume 1+2+...+i=k, then by 
                arithmetic series formula<br>
                i(i+1)/2=k<br>
                i^2+i-2k=0<br>
                i=(-1 + sqrt(1-8k)) / 2&nbsp; /* get the root */</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This i will be used as starting 
                value to get the final answer "n"</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">if (i*(i+1)/2 == k) then okay,<br>
                but if (i*(i+1)/2 &lt; k) then we have to increase this i (we still 
                need more)<br>
                &nbsp; when to stop increasing i?<br>
                &nbsp; if and only if (i*(i+1)/2 - k) can be divisible by two...<br>
                &nbsp;&nbsp;&nbsp; why?<br>
                &nbsp;&nbsp;&nbsp; k+2z=i(i+1)/2<br>
                &nbsp;&nbsp;&nbsp; for example:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1+2+3+4+5+6+7==28&nbsp;&nbsp;&nbsp;&nbsp; 
                (i=7)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28-12=16 is divisible by 
                2... and 16/2 is 8<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this 8 is actually 
                combination of -1-7=-8 (the negative part)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the smallest n to satisfy 
                the formula above is 7 =&gt; -1+2+3+4+5+6-7==12</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10033 - Interpreter">10033 - 
                        Interpreter</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Just simulate what they want..., straightforward. </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10034 - Freckles">10034 - 
                        Freckles</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A basic Minimum Spanning Tree problem, refer 
                to your algorithm book regarding how to compute MST, and now they change 
                this problem to Multiple Input format. For those who got WA after re-judge, 
                don't worry, just change your code into Multiple Input format and send again 
                =)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10035 - Primary Arithmetic">10035 - Primary Arithmetic</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simply calculate total carry.<br>
                (note, if total carry&gt;1 you must output ''operation<b>s</b>" 
                instead of "operation").</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10036 - Divisibility">10036 
                        - Divisibility</a> (By: Gawry)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Looks simple but if you use brute 
                force (count all possible values of +/- for N numbers) then 
                determine whether it is divisible by K or not, then your solutions 
                possibly get Time Limit Exceeded.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use mathematical properties + 
                Dynamic Programming</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Let d[1],...,d[N] be sequence of N 
                integers and t[I,J] (2 dimensional array, but after some 
                considerations, we'll find out that we only need 2 linear array of 
                size J) be true iff we can place +/- operators in the sequence of 
                first I integers so that result = J (mod K).</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">We can use DP to calculate t[I,J] 
                for all [I,J]:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">for i=1<br>
                t[1,j] = true for t[1,j] where j=abs(d[1]) mod K</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This means: You divide one integer 
                (the first integer from N integers) with K, get the remainder, 
                t[1,remainder] is set to be true.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">for i&gt;1<br>
                if t[i-1,j] true then<br>
                &nbsp; t[i,(j+abs(d[i]) mod K] = true /* add */<br>
                &nbsp; t[i,(j+K-abs(d[i]) mod K] = true /* substract */</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This means: For the 2nd integer up 
                to Nth integer, you either add it with previous remainder modulo K 
                or substract it with previous remainder modulo K, to get another 
                remainders in the range [0..K] that can be reached using 
                combination of i integers.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Answer should be Divisible iff 
                t[N,0], which means, you can arrange +/- operators in the sequence 
                of N integers, with remainder 0 / divisible.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10038 - Jolly Jumpers">10038 - Jolly 
                        Jumpers</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simply do what they want.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10041 - Vitos Family">10041 - Vito's 
                        Family</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Brute force calculation, simply try all 
                possible location of Vito's House, choose one that minimizes sum of distance 
                with his relatives.<span lang="en-gb"><br>
                    Hint: Sorting can simplify this problem, think about it...</span></font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10042 - Smith Numbers">
                        10042 - Smith Numbers</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem is similar to 583-Prime 
                Factors, you only have to sum up the digits, easy.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10048 - Audiophobia">10048 - 
                        Audiophobia</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Can be solved easily using O(N^3) Floyd 
                Warshall All Pairs Shortest Path. Read my programming section for 
                explanation of Floyd Warshall.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10050 - Hartals">10050 - Hartals</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The easiest way is to store a big array of 
                boolean, hartal_days[3651], initially all false. Then for each party, flag 
                the days which they have hartal. Take note about Friday &amp; Saturday. Finally, 
                count how many working days flagged..., simple.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10051 - Tower of Cubes">10051 - Tower 
                        of Cubes</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The underlying algorithm for this problem is 
                Dynamic Programming solution for Longest Increasing Subsequence. However, 
                you have to handle specific case with the cubes first. Good luck.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="10055 - Hashmat The Brave Warrior">
                        <font face="Verdana" size="2">10055 - Hashmat The Brave Warrior</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use long long data type (that means 
                use C++ compiler) + absolute function (create this function 
                yourself, standard abs is not enough).</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10060 - A Hole to Catch a Man">10060 - 
                        A Hole to Catch a Man</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Pure math problem. Just be careful with 
                precision error. Use epsilon rather than direct equality for floating point 
                numbers, i.e. instead of doing this: X == Y, you do this X - Y &lt; 0.0001, 
                where X and Y are floating point numbers.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10062 - Tell me the frequencies!">10062 - 
                        Tell me the frequencies!</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Simply count the ASCII frequency and output them in ascending order of their 
                frequencies.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10066 - The Twin Towers">10066 - The 
                        Twin Towers</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Simple Longest Common Subsequence (LCS) problem. Refer to my Dynamic 
                Programming page regarding LCS.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10067 - Playing with Wheels">10067 - 
                        Playing with Wheels</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                You can model this problem as a graph. You always have 8 ways to do 
                branching (there are 4 numbers, for each number you can either turn the 
                wheel to the left or turn to the right) minus the forbidden states if 
                encountered.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                So, what you need to do is to start from initial configuration, and then do 
                a graph traversal algorithm to reach the target configuration.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10071 - Back to High School  Physics">10071 - Back to High School 
                        Physics</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Simplest problem ever... just output 2*v*t</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10074 - Take The Land">10074 - Take The Land</a> (by: Maeenul)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana">
                <font size="2">This is a problem similar to the 108 (Maximum Sum) and 10667 
                (Largest Block).<br>
                &nbsp; <br>
                First fill the input matrix with 1 where the input is 0 and fill the 1s with 
                some very big negative number. The negative number must ensure that it is 
                bigger (in magnitude) than the total number of matrix entry (such as -n*n). 
                Then simply find the maximum sum from the matrix. That's it.</font><span style="font-weight: 400"><font size="2"> </font>
                </span></font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10075 - Airlines">10075 - Airlines</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Another all pairs shortest path problem. The most difficult part is in 
                determining the shortest distance on a sphere (earth). It is hard to solve 
                this problem without knowing the formula, please refer to my
                <a href="prog_computationalgeometry.html">computational geometry</a> section 
                to find out the formula. With this formula, the rest is solvable using Floyd 
                Warshall.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10077 - The Stern-Brocot Number System">10077 - The Stern-Brocot 
                        Number System</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Just do a simple binary search, starting from m1,n1,m2,n2 = (0,1,1,0), keep 
                finding total m = m1+m2 and total n = n1+n2, go to left, right or stop 
                according whether current<br>
                total m/total n is greater, lesser or equal to desired m/n, respectively.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10079 - Pizza Cutting">10079 - Pizza 
                        Cutting</a> (Proof by: Waldek Jarosik)</font></b></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                If you can derive the formula, this problem will be very simple. Just count 
                (n+n*n)/2 + 1.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1+n*(n+1)/2 Proof by Yaro (Waldek Jarosik):</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">We start with 0 cuts - in this case we have one 
                piece of pizza.<br>
                Consider we have n cuts done, whose gave us the maximal number of pieces.<br>
                Now let's think about what is the 'best' (n+1)-th cut<br>
                (a cut which gives us the maximal number of pieces).<br>
                If we draw a circle with some cuts done, it's easy to notice that the number of 
                pieces is:<br>
                previous number of pieces + 1 + number of previous cuts intersected by our new 
                cut.<br>
                There is always a way to make the cut that intersects ALL previous cuts.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This gives us a simple recursive formula:<br>
                &nbsp; t[0] = 1 (whole pizza)<br>
                &nbsp; t[n] = t[n-1] + n, n&gt;0 (previous number of cuts + 1 + n-1)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">But we can't save so big array in memory 
                (210*10^6) that's why we are looking for generalized formula.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Let's look at this:<br>
                &nbsp; t[n] = t[n-1]+n = (t[n-2]+n-1)+n = ((t[n-3]+n-2)+n-1)+n and so on..</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">In the end we reach the formula:<br>
                &nbsp; t[n] = t[0] + n-(n-1) + n-(n-2) + n-(n-3) + ... + n =<br>
                &nbsp; &nbsp; = 1 &nbsp; &nbsp;+ 1 &nbsp; &nbsp; &nbsp; + 2 &nbsp; &nbsp; &nbsp; + 3 &nbsp; &nbsp; &nbsp; + ... + n =<br>
                &nbsp; &nbsp; = 1 + (1+n) + (2+n-1) + (3+n-2) + ... + (floor(n/2) + ceil(n/2)) =<br>
                &nbsp; &nbsp; = 1 + (n+1) + (n+1) &nbsp; + (n+1) &nbsp; + ... + (n+1) [(n+1) occurs n/2 times]<br>
                &nbsp; &nbsp; = 1 + n*(n+1)/2</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10080 - Gopher II">10080 - Gopher II</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This problem is a maximum bipartite matching. Find the best assignment of 
                gopher and holes. First, construct the bipartite graph. Left side: Gophers, 
                Right side: Holes. Draw an edge from Gopher i to Hole j iff distance between 
                Gopher i and Hole j is within v*s time (remember your physics: v*s = 
                distance covered).</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                After you build this graph, just pass this to your Max Bipartite Matching or 
                Network Flow algorithm to get the result. Done.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10082 - WERTYU">10082 - WERTYU</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Simply simulate what they want.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10092 - The Problem with the Problem Setter">10092 - The Problem 
                        with the Problem Setter</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                The underlying algorithm for this "complex" problem is Maximum Flow.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Courier New" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                -&gt;(capacity c1) -&gt; Category1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Problem1 
                (capacity 1)--&gt;<br>
                Source -&gt;(capacity c2) -&gt; Category2 -**-&gt; Problem2 (capacity 1)--&gt; Sink<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt;(capacity cNk)-&gt; CategoryNk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                Problem3 (capacity 1)--&gt;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                ProblemNp(capacity 1)--&gt;<br>
                <br>
                ** Draw edge from category i to problem j if problem j can be classified to 
                category i (set capacity of these middle edges as 1)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Pass this Flow Graph to your Network Flow 
                algorithm (Ford Fulkerson, Edmund Karp, or anything else that you know) to 
                get the maximum flow. Output "1" and the selection of problems/category if 
                all categories has max flow. Output "0" otherwise...</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The conclusion is: to solve this problem, 
                you must study Network Flow algorithm first...<br>
                You can notice that this problem is VERY SIMILAR to 10249 (but 10249 is a 
                special version of this problem -&gt; 10249 can be solved using Greedy 
                algorithm)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10093 - An Easy Problem">10093 - An 
                        Easy Problem</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Convert the 0..9, A..Z (10..35), a..z (36..61) 
                representation to standard number first, I called it '<i>num</i>' and then 
                starting from the highest index, find the smallest N (2&lt;=N&lt;=62) such that <i>
                    num</i> modulo n == 0, then output <i>num+1</i>. (0..1 =&gt; base 2, 0..9 =&gt; 
                base 10, always +1).</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="10098 - Generating Fast, Sorted Permutation">
                        <font face="Verdana" size="2">10098 - Generating Fast, Sorted 
                        Permutation</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Similar to p195, this one is called 
                anagram, not permutation... I think.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10099 - The Tourist Guide">10099 - 
                        The Tourist Guide</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use Floyd Warshall O(N^3) All Pairs Shortest 
                Path algorithm. =)</font></p>



        </div>
    </div>
</div>
