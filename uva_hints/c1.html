<div data-page="10100" class="page">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="left"><a href="index.html" class="back link icon-only"><i class="icon icon-back"></i></a></div>
            <div class="center">Volume 101 (10100-10199)</div>
        </div>
    </div>

    <div class="page-content">
        <div class="content-block">




            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10100 - Longest Match">10100 - 
                        Longest Match</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This is another LCS-DP problem. But this time, 
                instead of characters, the matching is based on words. Refer to my Dynamic 
                Programming page. </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10101 - Bangla Numbers">10101 - 
                        Bangla Numbers</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Even though I didn't understand Bangla number 
                system, it seems that the key idea is to read 2 digits by 2 digits from 
                rightmost (minus two digits) except for 1 digit for shata.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Start from the rightmost digit minus two 
                digits, just cycle from shata read 1 digit, hajar, read 2 digits, lakh, read 
                2 digits, kuti, read another 2 digits, and go back to shata again. So, 
                45897458973958 will be transformed into something like this <b>45 </b>89<b> 
                    7 </b>45<b> 89 </b>73<b> 9 </b>58.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10102 - The path in the colored field">10102 - 
                        The path in the colored field</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                In this problem, we will be playing with minimum and maximum...</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                First, calculate the cost of reaching from any 1 to any 3,<br>
                Quick formula: Abs(1.x - 3.x) + Abs (1.y - 3.y).<br>
                Then find the minimum for every 1 in the table.<br>
                At last, find the maximum of all this numbers.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><a name="10104 - Euclid Problem"><b>
                        <font face="Verdana" size="2">10104 - 
                        Euclid Problem</font></b></a></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Search the Net (via google) for this information. "Extended 
                Euclid", use then simply use the formula given. =) </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10105 - Polynomial coefficients">10105 - 
                        Polynomial coefficients</a> (By: Maciej Ligenja)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <img src="img/10105-1.gif" height="48" border="0" width="444"></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">
                The only component in which xk is in n(k) power is: <br>
                <img src="img/10105-2.gif" height="48" border="0" width="196">, because (x1+..+xk-1)n-n(k) does not contain xk.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <img src="img/10105-3.gif" height="48" border="0" width="540"></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">
                And again the only component which contains xk in n(k) power and xk-1 in 
                n(k-1) power is:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <img src="img/10105-4.gif" height="43" border="0" width="345"><font face="Verdana" size="2"><!--[if gte mso 9]><xml>
                    <o:OLEObject Type="Embed" ProgID="Equation.3" ShapeID="_x0000_i1028" DrawAspect="Content" ObjectID="_1151857206">
                    </o:OLEObject>
                    </xml><![endif]-->, and so onâ€¦</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                The last stage is:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">
                <img src="img/10105-5.gif" height="41" border="0" width="595"></font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">
                We have a coefficient but in a very ugly form.<br>
                We know: n=n(1)+n(2)+..+n(k).<br>
                So:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <img src="img/10105-6.gif" height="85" border="0" width="436"></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">
                Our coefficient becomes:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">
                &nbsp;<img src="img/10105-7.gif" height="256" border="0" width="595"></font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">
                <b>
                    <a name="10106 - Product">10106 - Product</a></b></font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A good problem to test your elementary school 
                mathematic =). Just simulate your elementary school mathematic (use String 
                as your data structure)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10107 - What is the Median">10107 - 
                        What is the Median?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Another elementary school mathematic =). Just 
                simulate your elementary school mathematic.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10110 - Light, more light">
                        10110 - Light, more light</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Points to ponder:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1. You only have to care about the 
                last bulb, default state of last bulb is OFF<br>
                2. Every i'th walk, only bulbs which 
                serial divisible by i will be toggled<br>
                3. Let's examine the last bulb (bulb 
                "n"), all "i" which can divide "n" are factors of "n".<br>
                4. See this example: n=36, factors: 
                1,2,3,4,6,6,9,12,18,36<br>
                5. Walk no 1 will toggle last bulb 
                ON, walk no 2 will toggle it OFF, 3-&gt;ON, 4-&gt;OFF,<br>
                &nbsp;&nbsp;&nbsp;
                6-&gt;ON, 9-&gt;OFF, 12-&gt;ON, 18-&gt;OFF,36-&gt;ON<br>
                6. See this pattern like this: walk 1 
                paired with walk "n", walk 2 paired with walk "n-1",<br>
                &nbsp;&nbsp;&nbsp; walk 3 
                paired with walk "n-3", and so on until walk sqrt(n)<br>
                7. In each pairs, if one element 
                toggle last bulb ON, then the other will turn it OFF.<br>
                8. Since the default state of last 
                bulb is OFF, then to determine the final state of this bulb,<br>
                &nbsp;&nbsp;&nbsp; you 
                only have to check whether sqrt(n) is an INTEGER or not.<br>
                9. If sqrt(n) is integer, then we can 
                find integer x such that x*x=n.<br>
                &nbsp;&nbsp;&nbsp; Walk no "x" will turn the last 
                bulb ON (see example with n=36).</font></p><h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10111 - Find the Winning Move">10111 - 
                        Find the Winning Move</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This problem is just a simulation using backtracking.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                You are given an incomplete 4x4 tic-tac-toe board. Currently it is x's turn 
                and asked whether player 'x' can make a forced win. There is no direct 
                formula here... just try from top left (0,0) to bottom right (4,4), try 
                inserting 'x' in this coordinate and recursively check whether 'o' can't do 
                anything to stop x from winning (simulate using backtrack).</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Btw this hint may help: if you only have 2'x's and 2'o's (start of the 
                game), there is no winning move... (first sample input)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10112 - Myacm Triangles">10112 - 
                        Myacm Triangles</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Have you solved 478? You can use the formula of knowing whether a point is 
                inside a triangle here. However, this problem is quite complex and floating 
                point related... so be careful.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10113 - Exchange Rates">10113 - 
                        Exchange Rates</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Dynamic shortest path problem. You know the 'edges' (exchange rate) 
                dynamically. My brother's solution use Djikstra algorithm to find the lowest 
                exchange rate dynamically as new data are materialized. </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10115 - Automatic Editing">10115 - 
                        Automatic Editing</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Simply do what they want.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10116 - Robot Motion">10116 - Robot 
                        Motion</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Read the input into 2 dimensional array, start from corner, and simulate the 
                movement. Mark your path and count your path length along the way. If you 
                get outside the grid, then output "&lt;total path length&gt; to exit.". If you 
                encounter marked cell, this means you encounter a cycle. Use your path 
                counter to output the desired values.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10120 - Gift!">10120 - Gift?!</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A DP problem. Frank start from left bank and 
                at iteration i, Frank can only jump 2*i-1 meters</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Base case: Initially at iteration 1, Frank can 
                jump 1 meter.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Recursive case: From all stone j that Frank 
                can reach at iteration i, then stone[j-2*i-1] and stone[j+2*i+1] also 
                reachable provided that they doesn't fall outside the range [1..N].</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Just check whether stone[M] (where the gift is 
                located) is ever reached... Stop the algorithm if no more stones can be 
                reached... (algorithm will definitely terminate because jump length is 
                always increases, it will at one time jump outside range [1..N]).</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Now, since N can be very big (up to 10^6), we 
                need to speed up the algorithm by using a special case that when N &gt;= 49, no 
                matter where frog Funny put the gift, Frank will be able to reach it. Proof 
                by induction:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">if at N = i, all stones will be reachable then 
                at N = i+1, all stones will always be reachable too because at that time, 
                whatever your jump length is, we can always arrive from any of stone [1..i] 
                to reach stone i+1. This special index happens to be 49 in this case...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10124 - Subway">10124 - Subway</a> 
                    (by: Niaz Morshed Chowdhury)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Let's have some critical calculation. </font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">D 
                - the distance between stations, in metres<br>
                M - the maximum allowable speed of the train, in metres/sec<br>
                A - the maximum absolute acceleration of the train, in metres/sec2<br>
                J - the maximum absolute jerk, in metres/sec3</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                jtimeaccellimit = A/J<br>
                jtimespeedlimit = sqrt(M/J)<br>
                jtimedistlimit = exp(log(D/2/J)/3)<br>
                jtime = jtimeaccellimit</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Now...</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                if jtimespeedlimit &lt; jtime <br>
                &nbsp; then jtime = jtimespeedlimit<br>
                if jtimedistlimit &lt; jtime<br>
                &nbsp; then jtime = jtimedistlimit<br>
                <br>
                atime = (M - J*pow(jtime,2))/A<br>
                <br>
                a = 0.5*A<br>
                b = A*jtime + 0.5*J*pow(jtime,2)<br>
                c = J * pow(jtime,3) - D/2<br>
                r = (-b + sqrt(b*b - 4*a*c))/2/a<br>
                <br>
                if r &lt; atime<br>
                &nbsp; then atime = r<br>
                <br>
                dist = J * pow(jtime,3) + 0.5*J*pow(jtime,2)*atime + 0.5*A * pow(atime,2) + 
                A * atime*jtime<br>
                out_put = [4*jtime+2*atime+2*(D/2-dist)/M]</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10125 - Sumsets">10125 - 
                        Sumsets</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simply use O(n^4) algorithm, a 
                4-nested for loops. Note: my program is currently slow in problem 10125 rank list :-(, to improve the running 
                time, you might want to apply Dynamic Programming.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10126 - Zipfs Law">10126 - 
                        Zipf's Law</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You only have to be very 
                careful in tokenizing the input. Get the input line by line, tokenize 
                them into words, put them to a very big array of words, then sort 
                them, and finally count their frequencies. If the frequency equal 
                to "n", print them.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10127 - Ones">10127 - Ones</a> 
                    (by: Niaz Morshed Chowdhury)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This is a very easy but tricky problem. If you 
                want to calculate the sequence of one by increasing ONE, then two thing can 
                be happened.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1) If your data type is even long double (in C 
                it is the highest data type), it can not hold the sequence and because of 
                overflow you will get WA.<br>
                2) If your data type is string then you will get "time limit exceeded". To 
                avoid these problems we need to follow a trick here.<br>
                <br>
                The Algorithm<b><br>
                </b><br>
                input (it will be the input of the problem)&nbsp; <br>
                N=1 <br>
                one=1 (in this variable finally we get how many one will be in the sequence)
                <br>
                <br>
                </font><font face="Courier New" size="2">loop until we find the desired 
                answer
                {<br>
                &nbsp;&nbsp;if&nbsp;N &lt; input<br>
                &nbsp;&nbsp;&nbsp;&nbsp;append a '1'.&nbsp; (this the way -&gt; N=N*10+1)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;one = one + 1 <br>
                &nbsp;&nbsp;k = N mod input&nbsp; ( k is a variable )<br>
                &nbsp; do this until k = 0, otherwise N = k and repeat everything<br>
                }<br>
                </font><font face="Verdana" size="2"><br>
                <b>Example<br>
                </b><br>
                </font><font face="Courier New" size="2">Let the input is 3 <br>
                At first N = 1 and one&nbsp; = 1<br>
                <br>
                Now,<br>
                3 | 1 | but here N &lt; input so, append a '1'<br>
                one = one + 1 = 2<br>
                3 | 11| 3<br>
                &nbsp;&nbsp;&nbsp;&nbsp; 9<br>
                &nbsp;&nbsp; -----<br>
                &nbsp;&nbsp; &nbsp; 2<br>
                Now, k = 2, so, N=k;<br>
                again,<br>
                <br>
                3 | 2 | but here N &lt; input so append a '1'<br>
                one = one + 1 = 3<br>
                <br>
                3 | 21| 7<br>
                &nbsp;&nbsp;&nbsp; 21<br>
                &nbsp;&nbsp;-----<br>
                &nbsp;&nbsp;&nbsp;&nbsp; x<br>
                </font><font face="Verdana" size="2"><br>
                So the output is variable 'one' which contains the value 3</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Basically, this problem is a reverse version 
                of dividing a series of '1's with N. In the example above. The step by step 
                of dividing "111" with "3" is like this:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Courier New" size="2">3 |111| 37<br>
                &nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; =&gt; the same '9' that we see above<br>
                &nbsp; -----<br>
                &nbsp;&nbsp;&nbsp; 21<br>
                &nbsp;&nbsp;&nbsp; 21&nbsp; =&gt; the same '21' that we see above<br>
                &nbsp;&nbsp; ----<br>
                &nbsp;&nbsp;&nbsp;&nbsp; x</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">So, basically we just simulate this division 
                but without spanning out the actual string of '1's. </font></p>
            <font class="sf">
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10129 - Play on Words">10129 - Play 
                        on Words</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem can be solved using Euler Path 
                property. Read my programming-graph section.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10130 - SuperSale">10130 - SuperSale</a></font></b></h1>
            </font>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem is a 0-1 Knapsack problem 
                solvable using Dynamic Programming. Note: Top-down DP may be faster for 0-1 Knapsack 
                problem since most likely not all possible states are visited.</font></p>
            <font class="sf">
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10131 - Is Bigger Smarter">10131 - Is 
                        Bigger Smarter?</a></font></b></h1>
            </font>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem can be categorized as 
                2-constraints Longest Increasing Subsequence (LIS). First, sort the elephants 
                based on their decreasing IQ, then apply LIS based on their increasing 
                weight to these elephants. You got the answer. This problem is VERY SIMILAR 
                to problem 10154.</font></p>
            <font class="sf">
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10134 - Auto Fish">10134 - Auto Fish</a></font></b></h1>
            </font>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem is actually just a tedious... error prone... 
                simulation problem. Please read the constraints in the problem description properly... 
                That's all that I can tell you...</font></p>
            <font class="sf">
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10137 - The Trip">10137 - The Trip</a> 
                    (by: Neilor)</font></b></h1>
            </font>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The problem with this problem may be related 
                to precision error. Here is solution by Neilor:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">double highx = (int)((total/n+0.<wbr>0099)*100);<br>
                double lowx = (int)((total/n)*100);<br>
                highx /= 100;<br>
                lowx /= 100;<br>
                Where total is the total sum of the money and n is the number of students.<br>
                <br>
                Then, test each student money if is &gt; than highx or &lt; than lowx, accumulate 
                (student[i]-highx) or (lowx-students[i]), respectively.<br>
                Then, output the variable that have the bigger value.</font></p>
            <font class="sf">
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10140 - Prime Distance">
                        10140 - Prime Distance</a> (by: Zhang Kaicheng)</font></b></h1>
            </font>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Find the nearest and most distant 
                adjacent prime numbers within a range L&lt;=N&lt;=U.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use Sieve of Eratosthenes method.<br>
                from L,U (inclusively) we have d=U-L+1 numbers.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">bool flag[d];<br>
                use flag[i] to mark whether (L+i) is a prime number or not.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1)&nbsp; mark all to be true<br>
                &nbsp;&nbsp;&nbsp; for (i=0;i&lt;d;i++) { flag[i]=true;}</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">2) mark even numbers to be false<br>
                &nbsp;&nbsp;&nbsp; if (L is even) i=L else i=L+1;<br>
                &nbsp;&nbsp;&nbsp; for (;i&lt;d;i+=2) { flag[i]=false; }&nbsp;&nbsp;&nbsp;&nbsp;<br>
                <br>
                3) sieve by prime factors&nbsp;staring from 3 till sqrt(U)<br>
                &nbsp;&nbsp;&nbsp; </font><font face="Courier New" size="2">for (i=3;i&lt;=sqrt(U);i+=2) 
                {<br>
                &nbsp;&nbsp;&nbsp; if (i&gt;L &amp;&amp; !flag[i-L]) continue;<br>
                <br>
                &nbsp;&nbsp;&nbsp; // choose the first&nbsp;number to be sieved&nbsp;--&nbsp;&gt;=L,<br>
                &nbsp;&nbsp;&nbsp; //&nbsp;divisible by i, and not i itself!<br>
                &nbsp;&nbsp;&nbsp; j=l/i*i;<br>
                &nbsp;&nbsp;&nbsp; if (j&lt;L) j+=i;<br>
                &nbsp;&nbsp;&nbsp; if (j==i) j+=i; // if j is a prime number, have to 
                start form next one<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;// now start sieving<br>
                &nbsp;&nbsp;&nbsp; j-=L; // change j to the index representing j<br>
                &nbsp;&nbsp;&nbsp; for (;j&lt;d;j+=i) flag[j]=false;<br>
                &nbsp;&nbsp;}<br>
                <br>
                &nbsp; // mark 1 to be false, 2 true<br>
                &nbsp; if (L&lt;=1) flag[1-L]=false;<br>
                &nbsp; if (L&lt;=2) flag[2-L]=false;<br>
                </font><font face="Verdana" size="2"><br>
                4) use one iteration to find nearest and most distant adjacent 
                prime numbers.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10141 - Request for Proposal">10141 - 
                        Request for Proposal</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You don't need to store anything... I'll 
                explain using sample input...</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Courier New" size="2">6 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                // read 6 (number of requirements) and 4 (number of proposals)<br>
                engine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                brakes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                tires&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                ashtray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                vinyl roof&nbsp;&nbsp;&nbsp; // IGNORE<br>
                trip computer // IGNORE<br>
                Chevrolet&nbsp;&nbsp;&nbsp;&nbsp; // for each proposal, read their name<br>
                20000.00 3&nbsp;&nbsp;&nbsp; // remember their price and requirements 
                (higher the better)<br>
                engine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                tires&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                brakes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                Cadillac&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read the name<br>
                70000.00 4&nbsp;&nbsp;&nbsp; // since 4 &gt; 3, overwrite Chevrolet with 
                Cadillac<br>
                ashtray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                vinyl roof&nbsp;&nbsp;&nbsp; // IGNORE<br>
                trip computer // IGNORE<br>
                engine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                Hyundai&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read the name<br>
                10000.00 3&nbsp;&nbsp;&nbsp; // since 3 &lt; 4, don't overwrite Cadillac<br>
                engine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                tires&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                ashtray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE<br>
                Lada&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read the name<br>
                6000.00 1&nbsp;&nbsp;&nbsp;&nbsp; // since 1 &lt; 4, don't overwrite Cadillac<br>
                tires&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IGNORE</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Courier New" size="2">// Output "Cadillac"</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">See... You don't need to store ANYTHING except 
                best proposal name, highest number of requirements, and lowest price (when 
                number of requirements tied).</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10142 - Australian Voting">10142 - 
                        Australian Voting</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">Basically you are given a 
                    voting rule and list of votes. What you need to do is determine who is the 
                    winner under the voting system. There is no way to solve this other than 
                    simulate the process.</font></span></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10147 - Highways">10147 - Highways</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2"><span lang="en-gb">This is a partial MST 
                    problem. You already given fixed edges (highways that already built), and 
                    then you are asked to continue spanning the partial-MST (no longer 
                    guaranteed the minimum though, that's why I called it partial). See problem 
                    10397 for exactly similar problem.</span></font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10152 - ShellSort">1015<span lang="en-gb">2</span> - 
                        <span lang="en-gb">ShellSort</span></a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">In this problem, we are given 2 stacks, <b>
                    original</b> stack and <b>desired</b> stack from top to bottom (remember 
                this). Let's use sample input to understand my greedy algorithm.<br>
                <br>
                </font><font face="Courier New" size="2"><b>Original:</b>&nbsp;&nbsp;&nbsp;&nbsp; 
                |&nbsp; <b>Desired:<br>
                </b>Yertle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; Duke of Earl 
                (top)<br>
                Duke of Earl&nbsp; |&nbsp; Yertle<br>
                Sir Lancelot&nbsp; |&nbsp; Sir Lancelot (bottom)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Since the only move allowed is to pick a 
                turtle (in original stack) and then ask the turtle climb up to the top of 
                the stack. For example in the first input, if Duke of Earl go outside the 
                original stack and then climb on top of Yertle, you will get the desired 
                stack...<br>
                <br>
                </font><font face="Courier New" size="2">&nbsp;&nbsp; Duke now here &lt;---|<br>
                Yertle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                |<br>
                &nbsp;&nbsp;&nbsp;&nbsp; Duke of Earl ---|<br>
                Sir Lancelot</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Observe the pattern that those in bottom stack 
                didn't need to be altered since it already in the required order (in this 
                case: Sir Lancelot). Now let's see the second sample input, you should be 
                able to get the be very clear after this.<br>
                <br>
                </font><font face="Courier New" size="2"><b>Original:</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                |&nbsp; <b>Desired:</b><br>
                Yertle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                |&nbsp; Yertle<br>
                Duke of Earl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; Richard M. 
                Nixon<br>
                Sir Lancelot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; Sir Lancelot<br>
                Elizabeth Windsor&nbsp;&nbsp; |&nbsp; Duke of Earl<br>
                Michael Eisner&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; Elizabeth Windsor<br>
                Richard M. Nixon&nbsp;&nbsp;&nbsp; |&nbsp; Michael Eisner<br>
                Mr. Rogers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; Mr. 
                Rogers<br>
                Ford Perfect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; Ford Perfect<br>
                Mack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                |&nbsp; Mack<br>
                <br>
                </font><font face="Verdana" size="2">Find <b>maximal subsequence</b> of 
                turtles in <b>desired</b> stack (<b>continuously from bottom to top</b>) 
                inside the <b>original</b> stack, stop when you can't expand this 
                subsequence anymore. I will indicate this using numbers, see below.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Courier New" size="2"><b>Original:</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                |&nbsp; <b>Desired:</b><br>
                <b>-. Yertle ***</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
                <b>9. Yertle ***<br>
                </b>6. Duke of Earl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; <b>8. 
                    Richard M. Nixon **<br>
                    -. Sir Lancelot *</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; <b>7. Sir 
                    Lancelot *</b><br>
                5. Elizabeth Windsor&nbsp;&nbsp; |&nbsp; 6. Duke of Earl<br>
                4. Michael Eisner&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; 5. Elizabeth Windsor<br>
                <b>-. Richard M. Nixon **</b> |&nbsp; 4. Michael Eisner<br>
                3. Mr. Rogers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; 
                3. Mr. Rogers<br>
                2. Ford Perfect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; 2. Ford 
                Perfect<br>
                1. Mack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                |&nbsp; 1. Mack</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This greedy method is minimal and find the 
                unique solution... Now what you need to do is to print out 7,8,9 (Sir 
                Lancelot, Richard M. Nixon, and Yertle), in that order..., why?</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Because if you want Sir Lancelot to be 3-rd 
                topmost, you must ask him to go to the top first, and then ask 2 other 
                turtles (in this case, Nixon &amp; Yertle) to go on top of him later.<br>
                <br>
                Greedy works, my solution for this problem is very short :)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10154 - Weights and Measures">10154 - 
                        Weights and Measures</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">* This problem is not really a Longest 
                Increasing Subsequence-DP problem according to message board. I'll re-write 
                my code later.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10161 - Ants on a Chessboard">10161 - 
                        Ants on a Chessboard</a> (by: Md. Arifuzzaman)</font></b></h1>
            <div>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Courier New" size="2">sq = (floor)sqrt(N)<br>
                    distance = N- sq<br>
                    if (distance==0)x=1,y=sq<br>
                    else if (distance&lt;=sq+1)x=distance,y<wbr>=sq+1<br>
                    else x=sq+1, y=2*sq+2-distance</font></p></div>
            <div>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Courier New" size="2">if (sq%2==0) swap(x,y)<br>
                    print(x y)</font></p></div>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10162 - Last Digit">10162 - 
                        Last Digit</a> (by: Zhang Kaicheng)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use only last 2 digit of N</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">proof:</font></b></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">last digit of:<br>
                n-&gt;n^2-&gt;n^3-&gt;n^4-&gt;n^5<br>
                1-&gt;1-&gt;1-&gt;1-&gt;1<br>
                2-&gt;4-&gt;8-&gt;6-&gt;2<br>
                3-&gt;9-&gt;7-&gt;1-&gt;3<br>
                4-&gt;6-&gt;4-&gt;6-&gt;4<br>
                5-&gt;5-&gt;5-&gt;5-&gt;5<br>
                6-&gt;6-&gt;6-&gt;6-&gt;6<br>
                7-&gt;9-&gt;3-&gt;1-&gt;7<br>
                8-&gt;4-&gt;2-&gt;6-&gt;8<br>
                9-&gt;1-&gt;9-&gt;1-&gt;9<br>
                <br>
                You can see that for any digit a:<br>
                <b>lastDigit(a^1) = lastDigit(a^5) = ... = lastDigit(a^(4k+1)) for 
                    all k&gt;=0<br>
                    lastDigit(a^2) = lastDigit(a^6) = ... = lastDigit(a^(4k+2)) for 
                    all k&gt;=0<br>
                    lastDigit(a^z) = lastDigit(a^(4+z)) = ... = lastDigit(a^(4k+z)) 
                    for all k&gt;=0</b></font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Now consider two digit number (ab):<br>
                <b>lastDigit((ab+100)^(ab+100)) = <br>
                    lastDigit((ab+100)^(ab+4*25)) =<br>
                    lastDigit((ab+100)^ab)) = /* see above -&gt; lastDigit(a^(4*25+ab)=lastDigit(a^ab) 
                    lastDigit(ab^ab) /* now apply to the left side */</b></font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">By the derivation, we only have to 
                keep the last 2 digit, since<br>
                <b>lastDigit(xab) = lastDigit(ab)</b></font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10164 - Number Game">10164 - Number 
                        Game</a> (by: William Anggakusuma)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This is a backtracking + memoization problem. 
                Everytime you read a number, modulo it with N. Next, use backtracking to 
                generate all possible summation of those numbers (after you modulo it with 
                N). Use memoization to memorize the pair {sum, numbers taken} so far. You 
                need to use memoization because there will be many repeating sub problems.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10171 - Meeting Prof Miguel">10171 - Meeting Prof Miguel</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem is a double all-pairs shortest 
                path problem. After analyzing the problem description, you'll see that 
                actually you are given 2 separate directed graph (one for young/Manzoor, one 
                for people aged 30+/Prof Miguel). You also be given the initial starting 
                position of Manzoor and Prof Miguel.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">By executing all-pairs shortest path algorithm 
                such as Floyd Warshall to both directed graphs, you'll get:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">the shortest paths from initial position of 
                Manzoor to all other reachable places based on Manzoor's directed graph, and
                </font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">the shortest paths from initial position of 
                Prof Miguel to all other reachable places based on Prof Miguel's directed 
                graph.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Finally, find and output places in City of 
                Hope for which the sum of these Manzoor's and Prof Miquel's shortest paths 
                distance to this place is minimum. If such place exist, output "You will 
                never meet."</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10176 - Ocean Deep! Make it shallow!!">10176 - Ocean Deep! Make it 
                        shallow!!</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The basic thing to do is to modulo the given 
                binary number using 131071 (base 10). See explanation for problem 10551, 
                this problem is just a special case of 10551.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10183 - How Many Fibs">10183 - How Many Fibs?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">We know that Fibonacci number can be generated 
                sequentially using addition: i.e.,<br>
                given base case fib(1) = 1 and fib(2) = 1, we can have:<br>
                fib(3) = fib(1)+fib(2) = 1+1 = 2, then<br>
                fib(4) = fib(2)+fib(3) = 1+2 = 3, then<br>
                fib(5) = fib(3)+fib(4) = 2+3 = 5, and so on...</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Therefore if I ask you how many Fibonacci 
                between 3 &amp; 5, the answers are 3 which can be counted easily along with the 
                generation of those Fibonacci.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The problem is, a and b can be as big as 
                10^100. Therefore we can't solve this using standard data type, to handle 
                this, use your Big Integer library to solve this problem using the above 
                technique.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10187 - From Dusk Till Dawn">10187 - 
                        From Dusk Till Dawn</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                I haven't actually solve this problem. Still WA. But I'm confident it is 
                just a small bug inside my backtracking algorithm since this problem is 
                theoretically needs backtracking algorithm.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10188 - Automated Judge Script">10188 - 
                        Automated Judge Script</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                In this problem, you will have to manipulate string a lot. The hardest case 
                is in determining Presentation Error... However, I can give you some hints:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                1). Combine correct solution input into one string and submitted solution 
                input into another<br>
                &nbsp;&nbsp;&nbsp;&nbsp; string. After that, checking for accepted condition is 
                a simple string comparison.<br>
                &nbsp;&nbsp;&nbsp;&nbsp; However, we must ensure that n = m!!!<br>
                2). Checking for P.E. is only for numeric characters!!!, just ignore the 
                rest...<br>
                3). Anything else is Wrong Answer</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10189 - Minesweeper">10189 - 
                        Minesweeper</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Simulate Minesweeper game, easy.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10191 - Longest Nap">10191 - 
                        Longest Nap</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This problem is quite simple but parsing the input may be troublesome. You 
                can simplify the problem by converting the hh:mm format into minutes (09:00 
                =&gt; 9*60 = 360 ; 10:30 =&gt; 10*60+30 = 630, etc), then the rest is simply 
                integer comparison, just find the longest gap...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10192 - Vacation">10192 - 
                        Vacation</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Another LCS problem. Refer to my Dynamic Programming page.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10193 - All You Need Is Love">10193 - 
                        All You Need Is Love</a> (by: Md. Arifuzzaman)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Convert both integer number into decimal number n1 
                and n2.<br>
                if GCD(n1,n2)&gt;1 print-&gt;All you need is love!<br>
                else print-&gt;Love is not all you need!</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10194 - Football (aka Soccer)">10194 - 
                        Football (aka Soccer)</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This problem is a "simple" multi-field sorting (sorting with many field to 
                consider, in which one field has stronger priority than others). This can be 
                done using a modified comparison function to cater this sorting rule, and 
                simply pass this comparison function to your quick sort method.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                However, since the rules are very complex, you must be very careful not to 
                miss a single characters... (oh yeah, sort the team names lexicographically 
                if all others criteria are tied)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10195 - The Knights Of The Round Table">10195 - 
                        The Knights Of The Round Table</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This problem is just a simple mathematic problem, finding the largest circle 
                that can be fitted inside a triangle, given the side lengths of the 
                triangle.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                The standard formula can be found in Math books/websites..., here it is:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                s = (a+b+c)/2<br>
                r = sqrt((s-a)*(s-b)*(s-c)/s)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="10197 - Learning Portuguese">10197 - 
                        Learning Portuguese</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                There is no specific algorithm to solve this problem. Just do what the 
                problem wants...</font></p>






        </div>
    </div>
</div>
