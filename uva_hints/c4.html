<div data-page="10400" class="page">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="left"><a href="index.html" class="back link icon-only"><i class="icon icon-back"></i></a></div>
            <div class="center">Volume 104 (10400-10499)</div>
        </div>
    </div>

    <div class="page-content">
        <div class="content-block">


            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10400 - Game Show Math">10400 - 
                        Game Show Math</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">I 
                know that from the problem description, the maximum possible combination of 
                the solution is 4^100, which is impossible to calculate. However, I've tried 
                that backtracking with efficient pruning is enough to pass the time limit.
                Prune when: current value is &gt; 32.000 or &lt; -32.000, or when that value 
                already reached (which means your DFS create cycles...)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10404 - Bachets Game">10404 - 
                        Bachet's Game</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Working forwards from n to 0 is not recommended since the search space is 
                extremely too big. Instead, works backward.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                If you know that if n==0 and it's Ollie's turn, then Stan obviously win, 
                because Stan has just reached 0 previously.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                If n == 1, 3 or 8, the set of legal moves is {1,3,8}, and it's again Stan's 
                turn then Stan will win because his next step will reach state when n == 0 
                and Ollie's turn.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                If n == 2, the set of legal moves is {1,3,8}, and it's Stan's turn, then 
                Stan will lose since he can only move to state when n == 1 and Ollie's turn. 
                Ollie will then use her turn to win the game.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                Works this reasoning backwards, up to N. Apply Dynamic Programming by using 
                table to store the intermediate values.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10405 - Longest Common Subsequence">10405 - 
                        Longest Common Subsequence</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Refer to my programming page, Dynamic 
                Programming section, regarding LCS.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10407_-_Simple_division">10407 - 
                        Simple division</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The idea is to find GCD of multiple numbers.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Example from sample input 1:<br>
                The value d = 179 can divide the set of integers { 701 1059 1417 2312 },<br>
                leaving the same remainder r = 164.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Value d can be calculated by finding the GCD 
                of =<br>
                GCD (1059-701, 1417-701, 2312-701) =<br>
                GCD (358, 716, 1611) = 179</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Since GCD (179) will exactly divides 358, 716, 
                1611 without any remainders..., then <b><u>all</u></b> the original numbers 
                {701 1059 1417 2312} will have remainder of exactly 701 mod 179 = 164. Since 
                the input is in increasing order, the first number in the set will 
                definitely be the smallest and in overall this algorithm will output the 
                biggest d.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10408 - Farey sequences">10408 - 
                        Farey sequences</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">I know that there is a simpler pattern to 
                solve this problem. However, I've tried that using brute force can pass the 
                time limit. First, generate all possible (i,j) pairs where 1 &lt;= i,j &lt;= n, 
                and gcd(i,j) == 1... (this implies an O(n^2) algorithm), then sort them 
                using quick sort based on their fraction values. After that simply get the 
                k'th index and print it.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10409 - Die Game">10409 - 
                        Die Game</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Very easy, just simulate, total brute force...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10415 - Eb Alto Saxophone Player">
                        10415 - 
                        Eb Alto Saxophone Player</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Another simulation, use Boolean array to store 
                pressed/un-pressed state. Number of presses increased if and only if that 
                finger is currently in un-pressed state and now you pressed it. A lot of 
                'switches' and 'ifs' is required here.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10420 - List of Conquests">10420 - 
                        List of Conquests</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem is a simple frequency counting. 
                There are many ways to do this, the simplest is to sort the country names 
                (you can ignore all the girls' names...), then count how many time these 
                countries appears.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10422 - Knights in FEN">10422 - 
                        Knights in FEN</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A simple backtracking will do. The depth limit 
                is 11 moves, if you do it carefully, you should be able to pass the time 
                limit. There must be a faster way... (I see some of you can get Accepted 
                with less than 1 sec), however I don't know the trick yet...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10424 - Love Calculator">10424 - Love 
                        Calculator</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simply the value of 2 given string as given in 
                problem description (digit sum), then compare the ratio... remember that 
                ratio can't be greater than 100%, therefore you must select the smaller 
                between the 2 numbers as numerator and the larger as denominator :)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10432 - Polygon Inside A Circle">10432 - 
                        Polygon Inside A Circle</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">First, to avoid stupid precision error, define 

                pi = 2*acos(0.0) !!! Then to calculate the area of the polygon, simply 
                divide them into n smaller triangles. Based on the given radius r, you can 
                get the height and width of this small triangles by trigonometry relation. 
                Finally, calculate the total area of this n triangles :)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10440_-_Ferry_Loading_II">10440 - 
                        Ferry Loading II</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Greedy works. I will not give the proof here, 
                I don't like proofing. However the logical thought are as follows:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">For optimality the last ferry must take the 
                last n cars... correct?<br>
                Then... the 1st ferry must take the 1st car (car 0) up to car m%n if =&gt; m%n 
                != 0<br>
                or up to car n if m%n == 0... (otherwise last ferry won't take n cars...)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Now for each ferry trip, last car carried by 
                this ferry trip's time + 2*t is the time this ferry return (for subsequent 
                cars...). If any subsequent car arrives before this, they have to wait. 
                Shift all car arrival timings accordingly. (i.e. if ferry returns at time 
                50, all cars that arrive &lt; 50 must wait at least until time 50).</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Then, time the last car + t (one trip to the 
                other side) is the time last car arrive at destination, the completion time. 
                Done :D</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <b>
                    <font face="Verdana" size="2"><a name="10443 - Rock, Scissors, Paper">10443 - 
                        Rock, Scissors, Paper</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem is really about manipulating 
                array content (which is a bit hard to debug in my opinion). Prepare two grid 
                arrays (yes, you need 2!!!), then update the new array content based on the 
                content of the old array content + Rock, Scissors, Paper rule.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10450 - World Cup Noise">10450 - 
                        World Cup Noise</a> (explanation taken from Message Board)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">From the problem description, we must find the 
                number of all binary-strings of length n that don't have consecutive ones.<br>
                <br>
                Let f(n) = number of binary-strings of length n that don't have consecutive 
                ones. <br>
                <br>
                We can split f(n) into two:<br>
                1. f0(n) : number of strings that start with '0'. <br>
                2. f1(n) : number of strings that start with '1'. <br>
                <br>
                Let's consider f1(n)<br>
                If the string starts with '1', clearly the next digit has to be '0', so, the 
                strings are fixed to "10????...". Starting from s[2] until s[n-1], the 
                values are chosen so there is no consecutive ones. That means it is the same 
                as calculating f(n-2).<br>
                <br>
                f0(n) starts with '0', the next digit can be either '0' or '1' ... The 
                strings are only fixed to pattern "0????..." and the rest should be chosen 
                in such a way so that no consecutive ones are found. It's the same as 
                recursively calculating f(n-1). <br>
                <br>
                We can see that f(n) = f(n-2) + f(n-1) ... which is Fibonacci sequence.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10451 - Ancient Village Sports">10451 
                        - Ancient Village Sports</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem is basically a twisted problem 
                10432 (see above), if you know the formula to solve 10432, then you'll be 
                able to derive similar (but a bit different) formula to solve this.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10452 - Marcus, help!">10452 - 
                        Marcus, help!</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The issue of whether the God "IEHOVA" exist or 
                not is another issue. In this problem, use DFS to correctly choose the step 
                to reach the destination. Note that this path is definitely exist (see 
                problem description), so your output should always be 7 steps...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10465 - Homer Simpson">10465 
                        - Homer Simpson</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">I know the problem description seems unclear. 
                However after some contemplation, I realize that this is just a standard DP 
                problem. Create two arrays, maxBurger[1..T] and beer[1..T], then use the 
                following derivation:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Base case, from time t, from 1 to min(m,n) - 
                1:<br>
                &nbsp; The number of burger that Homer can take is 0, i.e. maxBurger[t] = 0;<br>
                &nbsp; Homer must drink t litres of beer, i.e. beer[t] = t;</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">General case, from time min(m,n) to T:<br>
                &nbsp; The number of burger that Homer can take is 
                max(maxBurger[t-n],maxBurger[t-m]) + 1<br>
                &nbsp; But, in this problem, we must consider another criteria, take those 
                burger if the <br>
                &nbsp;&nbsp;&nbsp; number of beer needed is smaller. I'll leave this to you to 
                figure out how to handle this :)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10466 - How Far">10466 
                        - How Far?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A simple trigonometry problem. I'm sure you 
                already know this formula from high school, that in right triangle: 
                length_of_x = cos(degree) * radius and length_of_y = sin(degree) * radius.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><font face="Verdana" size="2">
                This problem just ask you to calculate them...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10469 - To Carry or not to Carry">10469 
                        - To Carry or not to Carry</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use unsigned long, and then simply XoR them :)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10473 - Simple Base Conversion">10473 
                        - Simple Base Conversion</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Base number conversion is popular topic, refer 
                to math books if you don't know how to do this.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10474 - Where is the Marble">10474 
                        - Where is the Marble?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Read the input, sort them, then search the 
                query element using binary search. Don't forget to find the <u>first element 
                that is matched with the query</u> instead of the one that returned by 
            binary search.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10487 - Closest Sums">10487 
                        - Closest Sums</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Read the input, sort them, and then do O(n^2) 
                pairing..., if the sum has the closest match to the query, output it. Purely 
                brute force :p</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10489 - Boxes of Chocolates">1048<span lang="en-gb">9</span> 
                        - <span lang="en-gb">Boxes of Chocolates</span></a><span lang="en-gb"> (By: Niaz)</span></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A very simple problem. You will be given a 
                sequence of box descriptions. Just multiply the<span lang="en-gb"> </span>
                elements with each other and finally  MOD by <i><b>number of friends </b></i> 
                and the remainder will be the result. But there is a big problem. If you do 
                it this 
                way, your value will overflow. To avoid this, we will take the help of 
                modular operation. According to modular operation we can do MOD just after 
                each multiplication.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Example<span lang="en-gb">:</span></font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">input<br>
                1<br>
                5 1<br>
                3 2 3 4<br>
                output<br>
                4<br>
                <br>
                Calculation for this input<span lang="en-gb">:</span><br>
                R = 1<br>
                R = (R * 2) % 5&nbsp;&nbsp; <br>
                R = (R * 3) % 5<br>
                R = (R * 4) % 5</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Now R will holds 4. For large value this 
                method will help you to avoid overflow. <b>NOTE</b>: In case of more than 
                one line, take the sum for each line and finally MOD it with <i> <b>number 
                        of friends.</b></i></font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10490 - Mr. Azad and his Son!!!!!">10490 
                        - Mr. Azad and his Son!!!!!</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You can count it yourself, after that 
                pre-calculate the answers.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">First 10 primes &lt;= 31 are 
                {2,3,5,7,11,13,17,19,23,29,31};<br>
                n == 11 || n == 23 || n == 29 are prime but not perfect, exclude them.<br>
                For the rest, just calculate 2^(k-1) * (2^k - 
                1)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10491_-_Cows_and_Cars">10491 - 
                        Cows and Cars</a> (Derivation by: Victor Loh)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The solution for this problem is:<br>
                (1.0*(ncows*ncars+ncars*(ncars-1))/(ncows+ncars-nshow-1))/(ncows+ncars));</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Derivation:<br>
                P(winning a car) = P(car 1st &amp; change to another car) + P(cow 1st &amp; change 
                to car)<br>
                P(car 1st &amp; change to another car) = ncar/(ncar + ncow) * (ncar-1)/(ncar + 
                ncow - nshow - 1)<br>
                P(cow 1st &amp; change to car) = ncow/(ncar + ncow) * ncar/(ncar + ncow - nshow 
                - 1)<br>
                <br>
                Simplifying and we get your formula, and further simplification gives you:<br>
                <br>
                ncar * (ncow + ncar - 1)<br>
                ------------------------------<wbr>-----------<br>
                (ncow+ncar) * (ncow + ncar - nshow - 1)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10496_-_Collecting_Beepers">10496 - 
                        Collecting Beepers</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A simple backtracking problem. Simply 
                enumerate all possible paths that Karel may take. Prune the search tree as 
                necessary (when current length is already exceed best known shortest path 
                length).</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="10499 - The Land of Justice">10499 - 
                        The Land of Justice</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Okay, just follow this derivation:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1. Do you know that 4 * area of circle = area 
                of sphere (their diameter must be the same)<br>
                2. Every cut that you do, will create 2 * 1/2 * area of circle + 1/N * area 
                of sphere<br>
                3. If you have N cuts, you will have: N * (2 * 1/2 * area of circle + 1/ N * 
                area of sphere)<br>
                4. The formula can be simplified to: N * area of circle + area of sphere<br>
                5. Substitute area of circle == 1/4 area of sphere<br>
                6. Our formula is now: N/4 area of sphere + area of sphere<br>
                7. We want to know our profit: which is: area of all cuts / area of original 
                sphere<br>
                8. (1 + N/4) area of sphere / area of sphere == 1 + N/4, our profit is N/4.<br>
                9. Since we want it to be displayed in percentage, profit: N/4 * 100 ==&gt; <b>
                    N * 25</b>.<br>
                10. Finished... BUT... don't forget the special case: <b>if N == 1, you 
                    don't have any profit!!!</b></font></p>



        </div>
    </div>
</div>
