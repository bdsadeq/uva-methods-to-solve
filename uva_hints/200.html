<div data-page="200" class="page">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="left"><a href="index.html" class="back link icon-only"><i class="icon icon-back"></i></a></div>
            <div class="center">Volume 2 (200-299)</div>
        </div>
    </div>

    <div class="page-content">
        <div class="content-block">



            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="200 - Rare Order">200 - Rare Order</a> 
                    (by: Shaka)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">To determine the collating sequence:<br>
                1. Create a 2 dimension array (10000 rows * 21 chars/row is enough) and 
                a queue.<br>
                2. Read all input and store it in your 2 dimension array.<br>
                &nbsp;&nbsp;&nbsp; Btw do you realize that this problem is not a multiple input 
                problem. Only one test case<br>
                &nbsp;&nbsp;&nbsp; in this problem...<br>
                3. Read the first character from your array from the first input until the 
                last and store it<br>
                &nbsp;&nbsp;&nbsp; in the queue when you encounter a new character which has not 
                been in your queue.<br>
                4. Continue reading the 2nd character until the 20th character (the input 
                limit) and just do<br>
                &nbsp;&nbsp; the same as the first (enqueue it if it is not found in your queue). 
                Don't forget that<br>
                &nbsp;&nbsp; NOT all inputs consist of 20 characters.<br>
                5. After you finished reading all of your stored input, just print the queue.<br>
                <br>
                This algorithm works because the list will imply a complete ordering among 
                those letters that are used. It will obviously sorted by first characters 
                in the list, then by second characters, and so on. :)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="201 - Squares">201 - Squares</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">There is no other way to solve this problem 
                other than simulate it. Maximum size of N is 9 anyway. Record all the edges 
                given and then simply use brute force to try all combinations of squares 
                with size 1, size 2, ..., up to size n. Print the number of occurrences 
                appropriately. :)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="202 - Repeating Decimals">202 - Repeating 
                        Decimals</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Try to do fraction division manually, and 
                determine when the cycle repeats. This problem is EXACTLY SIMILAR to problem 
                275 (Expanding Fractions), only change output format. You can solve 2 problems 
                using one source code (with very minor changes) :-)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="208 - Firetruck">208 - Firetruck</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This is just a backtracking problem. Given 
                a city map, you must determine all valid routes from fire station (number 
                1) to a desired street corner. You must do a special check to test whether 
                your truck trapped in cycles and must do so efficiently.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="216 - Getting in Line">216 - Getting 
                        in Line</a> (with help from: Reuber's webpage)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">When you see the description, you'll find 
                out that max computer per test case is 8. A total DFS brute force search 
                + a bit pruning is sufficient to solve this problem. First, generate a table 
                of distance from each every computer to other computer (use Phytagoras formula), 
                and then enumerate all possible permutation of links for these computers 
                (max 7 links for 8 computers), save the best permutation so far, prune branches 
                that already exceed the current best. At the end, just print the result 
                with additional 16 feet per link.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="227 - Puzzle"><font face="Verdana" size="2">227 - Puzzle</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem involves complex array handling.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Since the input is very complicated, you need 
                to parse it. Put every single character in the first five rows to a 5x5-sized 
                array; remember the coordinate of the empty spot. Then you read all the 
                sequence of moves until you encounter ‘0’. There are 4 commands:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A: shift the character above the empty position 
                down,<br>
                &nbsp;&nbsp;&nbsp; then change the coordinate of the empty spot.<br>
                R: shift the character on the right of the empty position left,<br>
                &nbsp;&nbsp;&nbsp; then change the coordinate of the empty spot.<br>
                B: shift the character below the empty position up,<br>
                &nbsp;&nbsp;&nbsp; then change the coordinate of the empty spot.<br>
                L: shift the character on the left of the empty position right,<br>
                &nbsp;&nbsp;&nbsp; then change the coordinate of the empty spot.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Repeat all the process until you encounter 
                ‘Z’.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Common Mistake:<br>
                1. The sequence of moves may span more than one line, read the input carefully.<br>
                2. If something goes wrong (the coordinate go out from the boundary 1 to 
                5) then the Puzzle has no <br>
                &nbsp;&nbsp;&nbsp; final configuration, don’t do any more processing.<br>
                3. Don’t forget to display the puzzle with a space between each character.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="231 - Testing the CATCHER">231 - 
                        Testing the CATCHER</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Apply Dynamic Programming to Longest Decreasing 
                Subsequence problem. Click <a href="prog_dynamicprogramming.html">here</a> 
                to see my Dynamic Programming section if you don't familiar with this "Longest 
                Increasing/Decreasing Subsequence" problem.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="232 - Crossword Answers">232 - Crossword 
                        Answers</a> (with help from: Yudha Irsandy)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Quite complex array manipulation problem.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="239 - Tempus et mobilius. Time and motion">239 - Tempus et mobilius. 
                        Time and motion</a> (by: Ing Ing)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This is a simple math problem.<br>
                1. First, you have to simulate the ball movement, how long does it takes 
                to return to it's initial position<br>
                &nbsp;&nbsp; (t1 ... tn). (Compute the time required for all n balls)<br>
                2. Finally you have to compute the total time, where the total time is the 
                Least Common Multiple (LCM)<br>
                &nbsp;&nbsp; of all t1 ... tn. You can use associative characteristic of LCM: LCM(a, 
                b, c) = LCM(a, LCM(b, c))</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="254 - Towers of Hanoi">254 - 
                        Towers of Hanoi</a> (by: Md. Arifuzzaman</font></b><font face="Verdana" size="2">)</font></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Binary conversion of m in n bit make this 
                solution easier and interesting than we think.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">input: n and m (m input should be in 
                string or char array)<br>
                1. convert m into binary number<br>
                2. append zero at beginning if necessary to&nbsp;make it n bit binary number<br>
                (<br>
                &nbsp;example:<br>
                &nbsp;5 3<br>
                &nbsp;binary number: 00011<br>
                )<br>
                3. d[0]=d[1]=d[2]=0<br>
                4. beg=0, aux=1, dest=2<br>
                5. for bit 0 to n-1<br>
                &nbsp;if bit=0<br>
                &nbsp;&nbsp;d[beg]=d[beg]+1<br>
                &nbsp;&nbsp;swap(aux,dest)<br>
                &nbsp;else if bit=1<br>
                &nbsp;&nbsp;d[dest]=d[dest]+1<br>
                &nbsp;&nbsp;swap(aux,beg)<br>
                6.if even number of disk <br>
                &nbsp;print d[0] d[1] d[2]<br>
                &nbsp; else if odd number of disk<br>
                &nbsp;print d[0] d[2] d[1]</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="256 - Quirksome Squares">256 - Quirksome 
                        Squares</a> (by: Felix Halim)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem is very easy, since the possible 
                input only either 2,4,6, or 8, simply do a brute force calculation for all 
                those 4 possible input.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Here is the answer (yeah, you can send this 
                and get accepted...):</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">Input:</font></b></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">2<br>
                4<br>
                6<br>
                8</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">Output:</font></b></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">00<br>
                01<br>
                81<br>
                0000<br>
                0001<br>
                2025<br>
                3025<br>
                9801<br>
                000000<br>
                000001<br>
                088209<br>
                494209<br>
                998001<br>
                00000000<br>
                00000001<br>
                04941729<br>
                07441984<br>
                24502500<br>
                25502500<br>
                52881984<br>
                60481729<br>
                99980001</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="257 - Palinwords">257 - 
                        Palinwords</a> (by: Md. Arifuzzaman)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Very easy problem</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Courier New" size="2">1. input in word[257] //search for 
                first one<br>
                2. for i=2 to len-1<br>
                3.&nbsp; if word[j-1]=word[j+1]<br>
                4.&nbsp;&nbsp;c=word[j], d=word[j-1]<br>
                5.&nbsp;&nbsp;size=3<br>
                &nbsp;&nbsp;found=1<br>
                &nbsp;&nbsp;break<br>
                6.&nbsp;else if word[j]=word[j+1] and word[j-1]=word[j+2]<br>
                7.&nbsp;&nbsp;c=word[j], d=word[j-1]<br>
                8.&nbsp;&nbsp;size=4<br>
                &nbsp;&nbsp;found=1<br>
                &nbsp;&nbsp;break<br>
                //if first one found search second one<br>
                9. for j=i+1 to len-1<br>
                10. &nbsp;if word[j-1]=word[j+1]<br>
                11. &nbsp;&nbsp;if size=4 or (c!=word[j] || d!=word[j-1])<br>
                12.&nbsp;&nbsp;print YES <br>
                &nbsp;&nbsp;break;<br>
                13&nbsp;else if word[j]=word[j+1] and word[j-1]=word[j+2]<br>
                14.&nbsp;&nbsp;if size=3 or (c!=word[j] || d!=word[j-1])<br>
                &nbsp;&nbsp;&nbsp;print YES<br>
                &nbsp;&nbsp;&nbsp;break;<br>
                15. if j=len <br>
                16. &nbsp;print NO</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="259 - Software Allocation">2<span lang="en-gb">59</span> 
                        - <span lang="en-gb">Software Allocation</span></a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2"><span lang="en-gb">This problem naturally 
                    fit as a Constraint Satisfaction Problem (CSP).</span></font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">Constraint: There are 10 
                    computers, each of them can run 0 to 1 applications (one of the 26 applications 
                    or don't run anything).</font></span></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">Your task is to find an 
                    assignment such that it satisfy the constraint and the number of applications 
                    brought by the user...</font></span></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">To solve this, first reduce 
                    the domain of each computer from 27 assignments to the smallest size using 
                    domain reduction. For example if application 'A' can only be run in computer 
                    0, then remove all 'A' in computer 1 to 9... Then do backtracking to enumerate 
                    all possible assignments in this reduced domain, then check whether this 
                    assignment satisfy the user requirement. Done :)</font></span></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="260 - Il Gioco dellX">2<span lang="en-gb">60 
                            - Il Gioco dell'X</span></a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">When usually in graph traversal, 
                    you go to either 4 direction (up,right,down,left) or 8 directions (including 
                    diagonals), this time you are given special graph, which cell's have 6 neighbours. 
                    You need to check whether from leftmost, there is a way to reach rightmost 
                    (which means white wins) or the other way, topmost to bottommost (black 
                    wins). You can do simple backtracking, but the easiest way to solve this 
                    problem is to do flood fill. flood fill all 'w' starting from leftmost with 
                    colour A, and flood fill all 'b' starting from topmost with colour B. Finally 
                    check whether there exist a colour A in rightmost column (white wins) or 
                    colour B in bottommost row (black wins).</font></span></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="263 - Number Chains">263 - Number 
                        Chains</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">With a tool to sort characters in descending 
                and ascending (qsort), a tool to convert this characters into integer (atoi), 
                and a list (just a short list will do) to memorize the past few numbers 
                generated... You can simply simulate this problem efficiently. No tricks, 
                no traps, just simulate it... </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="264 - Count on Cantor">264 - Count 
                        on Cantor</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A brute force simulation may be possible, 
                but you can solve this problem in a more efficient manner if you can derive 
                the formula. Study the pattern and derive it.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="270 - Lining Up">270 - Lining Up</a> 
                    (by: Lego Haryanto)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Problem summary: You are given N points (N 
                &lt;= 700), we need to print the maximum number of points that can be 
                passed through by one straight line.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This algorithm is O(n<sup>2</sup> lg n), AC 1.9xx 
                s in UVa OJ. There may be better algorithm than this.<br>
                <br>
                Solution:<br>
                The key idea: angular sorting.<br>
                <br>
                Let the first point from n points be chosen as pivot. With other words, we 
                assume our optimal line will pass through this pivot. Then, sort (n-1) remaining 
                points according to angle with respect to pivot. Then we have order of the 
                points that we can use as reference to count how many collinear points (pseudo 
                code below).<br>
                <br>
                Then, we repeat the abovementioned procedure with the second point as the pivot, 
                and so on until we have tried all points as pivot.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Pseudo code:<br>
                <br>
                </font><font face="Courier New" size="2">for (pivot = 0; pivot &lt; n; pivot++) {<br>
                &nbsp; sort other points by angle with respect to pivot. // O (n lg n)<br>
                <br>
                &nbsp; // O (n) algorithm to determine how many collinear points with this pivot<br>
                &nbsp; lo = 1; hi = 2;<br>
                &nbsp; while (hi &lt; n-1) {<br>
                &nbsp;&nbsp; &nbsp;if (collinear(pivot, lo, hi))<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hi++;<br>
                &nbsp;&nbsp; &nbsp;else {<br>
                &nbsp;&nbsp;&nbsp; &nbsp; maxCount = max(maxCount, hi-lo+1);<br>
                &nbsp; &nbsp; &nbsp; lo = hi++;<br>
                &nbsp;&nbsp; &nbsp;}<br>
                &nbsp; }<br>
                <br>
                &nbsp; maxCount = max(maxCount, hi-lo+1);<br>
                }</font><font face="Verdana" size="2"><br>
                <br>
                Thus the complexity is O(n<sup>2</sup> lg n)<br>
                <br>
                Optimization:<br>
                This algorithm can be optimized by first sorting the points according to 
                y-coordinates. Then, for ties, sort according to x-coordinates.<br>
                <br>
                Then, proceed as before, but the inner loop don't need to handle (n-1) points 
                but just the "remaining points" starting from the point (pivot+1) in sorted 
                order. That is, the more pivots that have been examined, the number of 
                "remaining points" to be sorted decreases.<br>
                <br>
                We do not need to care about the ignored points as we have taken care of them 
                when we set them as pivot previously.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="271 - Simply Syntax">271 - Simply 
                        Syntax</a> (by: Niaz Morshed Chowdhury)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem its not that much easy as it 
                looks. For this problem I am giving here an Algorithm, afterwards I will 
                explain it.<br>
                <br>
                </font><font face="Courier New" size="2">n = 0 // a variable containing 
                total sentence, initialized as ZERO.<br>
                bank[1000] // here the given line will be stored<br>
                len = length of [bank]<br>
                <br>
                for i = len - 1 down to 0 {<br>
                &nbsp; if bank[i] == any character between p through z<br>
                &nbsp;&nbsp;&nbsp; n = n+1 <br>
                &nbsp; else if bank[i] == any character from C,D,E,I<br>
                &nbsp;&nbsp;&nbsp; if n &gt; = 2<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = n - 1<br>
                &nbsp;&nbsp;&nbsp; else <br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = 0<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<br>
                &nbsp; else if bank[i] == character N<br>
                &nbsp;&nbsp;&nbsp; if n &lt; 1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = 0<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<br>
                &nbsp;&nbsp;&nbsp; else<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = n // no change in 'n'<br>
                }</font><font face="Verdana" size="2"><br>
                <br>
                After completing the FOR loop.....<br>
                <br>
                </font><font face="Courier New" size="2">if n == 1<br>
                &nbsp; Print YES<br>
                else<br>
                &nbsp; Print NO</font><font face="Verdana" size="2"><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
                Now I am describing how does this algorithm work.<br>
                <br>
                1. Any character from p to z is a correct sentence. So, when we get any 
                of them we just increase the total sentence (n).<br>
                2. Two correct sentences and any one of C,D,I,E make a correct sentence. 
                But this time at first our sentence number decrease two. <br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                n = n -2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                <br>
                But with C,D,I,E it makes a new sentence. So,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                n = n + 1<br>
                So, finally we get,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                n = n - 2 + 1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                n = n - 1<br>
                3. One correct sentence and N make a new sentence. Here also at first total 
                sentence decrease one but then it increase again one. As a result there 
                is no change in 'n'.<br>
                4. If we get less than two sentence before C,D,E &amp; I, we just break the 
                loop with assigning 0 at n. Finally it will work as flag. You may notice 
                that we do not break the loop if we get more than two correct sentence. 
                This is because to make with [C...I] we need two sentence and the extras 
                are might be for some other parts. If not then we can track it later. But 
                we can not consider less then two. <br>
                5. Same explanation goes for N also.<br>
                6. But...finally we must get one and only one correct sentence to tell that 
                its is correct. If we don't get n = 1, then we can surely say that its not 
                a correct sentence.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="272 - TEX Quotes"><font face="Verdana" size="2">272 - TEX Quotes</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">"This is bad quote".<br>
                `` This is elegant quote ' '<br>
                Simply replace all " to their corresponding opening/closing quote, use flag 
                to determine this.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="273 - Jack Straws">273 - Jack Straws</a> 
                    (by: Sohel Hafiz)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana"><font size="2">First run a n<sup>2</sup> loop to mark 
                the straws that are directly connected to some other straws. Use adjacency 
                matrix to store this information. Use line intersecting algorithm (see CLRS 
                computational geometry chapter) to find the intersection. Then simply apply 
                Floyd Warshall to see whether a straw is connteced to some other straw (i.e. 
                there is a path from a source straw to a destination straw). Since there 
                is at most 12 straws, Floyd Warshall will pass the time limit</font><b><font size="2">.</font></b></font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="275 - Expanding Fractions"><font face="Verdana" size="2">275 - 
                        Expanding Fractions</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">EXACTLY SIMILAR to problem 202 (Repeating 
                Decimals), only change output format. You can solve 2 problems using one 
                source code (with very minor changes) :-)</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="278 - Chess">278 - Chess</a> (with 
                    help from: Felix Halim)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">From various observation, I found out the 
                following rules:</font></p>
            <ol>
                <li>
                    <p style="margin-left: 10; margin-right: 10" align="left">
                        <font face="Verdana" size="2">Maximum rooks in an m*n chessboard so 
                        they are not in position to take any other rook is minimum (m,n).</font></p>
                </li>
            </ol>
            <blockquote>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Verdana" size="2">Proof: To make a rook does not attack 
                    other rook, each rook must be placed in a different row and different 
                    column with other rook. The easiest way to do this is to place these 
                    rooks diagonally.</font></p>
            </blockquote>
            <div align="center">
                <center>
                    <table style="border-collapse: collapse; text-align: center" id="AutoNumber1" border="1" cellpadding="0" cellspacing="0" width="80">
                        <tbody><tr>
                                <td bgcolor="#00FFFF" width="25%">
                                    <p style="text-align: left">r1</p>
                                </td>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                            </tr>
                            <tr>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td width="25%">
                                    <p style="text-align: left">r2</p>
                                </td>
                                <td width="25%">&nbsp;</td>
                                <td width="25%">&nbsp;</td>
                            </tr>
                            <tr>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td width="25%">&nbsp;</td>
                                <td width="25%">
                                    <p style="text-align: left">r3</p>
                                </td>
                                <td width="25%">&nbsp;</td>
                            </tr>
                            <tr>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td width="25%">&nbsp;</td>
                                <td width="25%">&nbsp;</td>
                                <td width="25%">
                                    <p style="text-align: left">r4</p>
                                </td>
                            </tr>
                        </tbody></table>
                </center></div>
            <p align="left"><font face="Verdana" size="2">Figure 1. One of the optimal 
                rooks placement.</font></p>
            <ol>
                <li value="2">
                    <p style="margin-left: 10; margin-right: 10" align="left">
                        <font face="Verdana" size="2">Maximum queens in an m*n chessboard (m&gt;=4 
                        and n&gt;=4) so they are not in position to take any other queen is minimum 
                        (m,n).</font></p>
                </li>
            </ol>
            <blockquote>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Verdana" size="2">Proof: To make a queen does not attack 
                    other queen, each queen must be placed in a different row, different 
                    column, and different diagonal with other queen. You can do backtracking 
                    to do this. However, in problem 278, you are only have to find the maximum 
                    number of queens, not their position.</font></p>
            </blockquote>
            <div align="center">
                <center>
                    <table style="border-collapse: collapse; text-align: center" id="AutoNumber2" border="1" cellpadding="0" cellspacing="0" width="80">
                        <tbody><tr>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td bgcolor="#00FFFF" width="25%">
                                    <p style="text-align: left">q1</p>
                                </td>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                            </tr>
                            <tr>
                                <td width="25%">
                                    <p style="text-align: left">q2</p>
                                </td>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                            </tr>
                            <tr>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td width="25%">&nbsp;</td>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td width="25%">
                                    <p style="text-align: left">q3</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="25%">&nbsp;</td>
                                <td width="25%">
                                    <p style="text-align: left">q4</p>
                                </td>
                                <td bgcolor="#00FFFF" width="25%">&nbsp;</td>
                                <td width="25%">&nbsp;</td>
                            </tr>
                        </tbody></table>
                </center></div>
            <p align="left"><font face="Verdana" size="2">Figure 2. One of the optimal 
                queens placement.</font></p>
            <ol start="3">
                <li>
                    <p style="margin-left: 10; margin-right: 10" align="left">
                        <font face="Verdana" size="2">Maximum knights in an m*n chessboard so 
                        they are not in position to take any other knights is maximum (black 
                        tiles,white tiles).</font></p>
                </li>
            </ol>
            <blockquote>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Verdana" size="2">Proof: A knight on a black tile cannot 
                    attack any piece on any other black tiles, and a knight on white tile 
                    cannot attack any piece located on any other white tiles. By simply 
                    placing all knights in either all white tiles or all black tiles, you 
                    can make sure these rooks will not attack each other. To maximize the 
                    number of knights, you should choose maximum (black,white) as your answer.</font></p>
            </blockquote>
            <div align="center">
                <center>
                    <table style="border-collapse: collapse; text-align: center" id="AutoNumber3" border="1" cellpadding="0" cellspacing="0" width="80">
                        <tbody><tr>
                                <td width="25%">
                                    <p style="text-align: left">k1</p>
                                </td>
                                <td bgcolor="#000000" width="25%">&nbsp;</td>
                                <td width="25%">
                                    <p style="text-align: left">k2</p>
                                </td>
                                <td bgcolor="#000000" width="25%">&nbsp;</td>
                            </tr>
                            <tr>
                                <td bgcolor="#000000" width="25%">&nbsp;</td>
                                <td width="25%">
                                    <p style="text-align: left">k3</p>
                                </td>
                                <td bgcolor="#000000" width="25%">&nbsp;</td>
                                <td width="25%">
                                    <p style="text-align: left">k4</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="25%">
                                    <p style="text-align: left">k5</p>
                                </td>
                                <td bgcolor="#000000" width="25%">&nbsp;</td>
                                <td width="25%">
                                    <p style="text-align: left">k6</p>
                                </td>
                                <td bgcolor="#000000" width="25%">&nbsp;</td>
                            </tr>
                            <tr>
                                <td bgcolor="#000000" width="25%">&nbsp;</td>
                                <td width="25%">
                                    <p style="text-align: left">k7</p>
                                </td>
                                <td bgcolor="#000000" width="25%">&nbsp;</td>
                                <td width="25%">
                                    <p style="text-align: left">k8</p>
                                </td>
                            </tr>
                        </tbody></table>
                </center></div>
            <p align="left"><font face="Verdana" size="2">Figure 3. One of the optimal 
                knights placement.</font></p>
            <ol start="4">
                <li>
                    <p style="margin-left: 10; margin-right: 10" align="left">
                        <font face="Verdana" size="2">Maximum Kings in an m*n chessboard so 
                        they are not in position to take any other Kings is (m+1) div 2 * (n+1) 
                        div 2</font></p>
                </li>
            </ol>
            <blockquote>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Verdana" size="2">Proof: A King can reach all directions 
                    with length 1. By placing each King like the figure below (separated 
                    with length &gt; 1), you can make sure these Kings will not be able to 
                    attack each other.</font></p>
            </blockquote>
            <center>
                <table style="border-collapse: collapse; text-align: center" id="AutoNumber4" border="1" cellpadding="0" cellspacing="0" width="80">
                    <tbody><tr>
                            <td width="25%">
                                <p style="text-align: left">K1</p>
                            </td>
                            <td bgcolor="#000000" width="25%">&nbsp;</td>
                            <td width="25%">
                                <p style="text-align: left">K2</p>
                            </td>
                            <td bgcolor="#000000" width="25%">&nbsp;</td>
                        </tr>
                        <tr>
                            <td bgcolor="#000000" width="25%">&nbsp;</td>
                            <td width="25%">&nbsp;</td>
                            <td bgcolor="#000000" width="25%">&nbsp;</td>
                            <td width="25%">&nbsp;</td>
                        </tr>
                        <tr>
                            <td width="25%">
                                <p style="text-align: left">K3</p>
                            </td>
                            <td bgcolor="#000000" width="25%">&nbsp;</td>
                            <td width="25%">
                                <p style="text-align: left">K4</p>
                            </td>
                            <td bgcolor="#000000" width="25%">&nbsp;</td>
                        </tr>
                        <tr>
                            <td bgcolor="#000000" width="25%">&nbsp;</td>
                            <td width="25%">&nbsp;</td>
                            <td bgcolor="#000000" width="25%">&nbsp;</td>
                            <td width="25%">&nbsp;</td>
                        </tr>
                    </tbody></table>
            </center>
            <p align="left"><font face="Verdana" size="2">Figure 4. One of the optimal 
                Kings placement.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="280 - Vertex">280 - Vertex</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A sample problem to train your Depth First 
                Search skill. The input format is actually an adjacency list, however you 
                can use adjacency matrix if you like. However, please note that N is from 
                1 to 100 !!!, don't declare 1000 or you'll get Time Limit Exceeded/Crash, 
                and don't declare &lt; 100 or you'll get Wrong Answer...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="291 - The House Of Santa Claus">291 
                        - The House Of Santa Claus</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Backtracking will solve this problem.<br>
                Tip: Since there are only 44 solutions for this problem, pre-calculate them 
                is a good idea.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="294 - Divisors">294 - Divisors</a> 
                    (with help from: Ed Karrels webpage)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">An inefficient program will always give you 
                Time Limit Exceeded. Refer to many mathematic websites and verify this formula:
                </font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">if the number is a^i * b^j * c^k * ...,<br>
                then it has (i+1)(j+1)(k+1)... divisors.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="297 - Quadtrees">297 - Quadtrees</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Create an image buffer (i.e. a 2-dimensional 
                Boolean array) of size 32 x 32. Initialize everything to false (white), 
                then according to Quadtrees rule given in problem description, fill the 
                image buffer with true (black) for the first tree and second tree. (Note: 
                the second tree will overwrite any black cell used by first tree, this is 
                what we want). Finally, count how many black cells in the image buffer, 
                and output this value.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="299 - Train Swapping">299 - Train 
                        Swapping</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Long problem explanation..., but this problem 
                is simple, just count the Bubble Sort swaps in O(n<sup>2</sup>). However, 
                you can solve this problem by counting inversion index using Merge Sort 
                O(n lg n).</font></p>



        </div>
    </div>
</div>
