<div data-page="500" class="page">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="left"><a href="index.html" class="back link icon-only"><i class="icon icon-back"></i></a></div>
            <div class="center">Volume 5 (500-599)</div>
        </div>
    </div>

    <div class="page-content">
        <div class="content-block">


            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="501 - Black Box">501 - Black Box</a> 
                    (by: Alexander Dolin)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use two heap data structures, one is 
                maximum heap (heap1) and the other is minimum heap (heap2). At the step
                <i>i</i>, we have to find the number with order statistic <i>i </i>in 
                the final sorted array. So, we keep first <i>i-1</i> numbers in heap1, 
                other numbers in heap2. Minimum from heap2 will be the answer.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="507 - Jill Rides Again">507 - Jill 
                        Rides Again</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The underlying algorithm for this problem is 
                a "maximum interval sum", and there is a nice <b>linear time</b> DP 
                algorithm to solve this problem (yes only linear time algo can pass the 
                time limit, since the problem size can be as big as 20000 'stops'.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Courier New" size="2">Niceness[i] 
                = Niceness[start] + ... + Niceness[i]<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                if sum from index 'start' to i is &gt;= 0 <b>or</b><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                Niceness[i], set start=i+1 (start new interval)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                if sum from index 'start' to 'i' &lt; 0</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The simple reasoning of this DP formulation 
                is as follows: if you have positive (or zero) sum, then this current 
                sequence can still be extended to a longer interval with bigger value or 
                at least similar value but longer interval... but if the partial sum is 
                negative... then there is no point to extend it further...</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Example from sample input:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Courier New" size="2">Niceness: -1 <b>6</b><br>
                Sum&nbsp;&nbsp;&nbsp;&nbsp; : -1 <b>6</b><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max sum</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Courier New" size="2">Niceness: 4 -5&nbsp; <b>4 -3&nbsp; 4&nbsp; 4 -4&nbsp; 
                    4</b> -5<br>
                Sum&nbsp;&nbsp;&nbsp;&nbsp; : 4 -1&nbsp; <b>4&nbsp; 1&nbsp; 5&nbsp; 9&nbsp; 
                    5&nbsp; 9</b>&nbsp; 4<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                ^<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                max sum</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Courier New" size="2">Niceness: <b>-2</b> -3 -4<br>
                Sum&nbsp;&nbsp;&nbsp;&nbsp; : <b>-2</b> -3 -4<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max sum, but negative... no nice 
                parts</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">So, just do a linear sweep from left to 
                right, accumulate the sum one element by one element, start new interval 
                whenever you encounter partial sum &lt; 0... At the end, output the longest 
                and most nicest, "j-i" interval.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="514 - Rails"><font face="Verdana" size="2">514 - Rails</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Using only one-end station (Hint: 
                a Stack), you must determine whether it is possible to marshal 
                the coaches in the order required on the corresponding line of 
                the input file.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Output "Yes" if it is possible, 
                otherwise output "No". Solution:<br>
                1. Use a stack.<br>
                2. Trial &amp; Error using a piece of 
                blank paper first, then you'll see the pattern.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Common Mistake:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1. Input can be like this</font></p><blockquote>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Verdana" size="2">5<br>
                    1 4 3 2 5<br>
                    0<br>
                    0<br>
                    <br>
                    And the output for this is "Yes".</font></p></blockquote>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">2. Incorrect stack implementation, 
                an 1000-elements array is sufficient.</font></p><h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="516 - Prime Land"><font face="Verdana" size="2">516 - 
                        Prime Land</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You are given a "Prime 
                representation" of an integer number X |&nbsp; 2&lt;X&lt;=32767.<br>
                Then you have to decrement X by 1, and then output the value of 
                X in its new "Prime representation"</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Example of "Prime representation":</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Let X=5, then Prime representation 
                of X is 5^1 (Written "5 1")<br>
                Let X=10, then Prime representation of X is 5^1 * 2^1 (Written 
                "5 1 2 1")<br>
                Let X=100, then Prime representation of X is 5^2 * 2^2 (Written 
                "5 2 2 2")</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">So "Prime representation" is the 
                form of product of powers of prime factors. There will only be
            <u>one</u> way to represent X in its "Prime representation" for 
            all X&gt;1. Solution:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1. Convert "prime representation" 
                to an integer X, multiply the powers of prime 
                factors of X.<br>
                2. Decrement X by 1.<br>
                3. Turn X into its "Prime representation" again. Use prime factors 
                algorithm<br>
                (See my programming page) ~&gt;
                (Similar to number 583).</font></p><h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="524 - Prime Ring Problem">524 - Prime Ring Problem</a> (with 
                    help from: Arief, Lucas)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem can be solved using efficient 
                backtracking. Even though n is "just" 16, finding the combination of 
                "prime ring" can be as big as 16! if you do brute force. Prune whenever 
                you can.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="526 - String Distance and Transform Process">526 - String 
                        Distance and Transform Process</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Although Edit Distance DP algorithm is quite 
                popular. It's a bit hard to tweak the code to get it accepted by the 
                judge. I can only say good luck in tweaking your Edit Distance / 
                Approximate String Matching algorithm.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="529 - Addition Chains">529 - Addition Chains</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Again, this is another backtracking problem. 
                Always remember the rule of thumb: "Prune whenever you can"</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="530 - Binomial Showdown">530 - Binomial Showdown</a> (by: Felix 
                    Halim)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This is just standard nCr 
                (Combination) calculation, where nCr = n! / (r!*(n-r)!).<br>
                But this one uses very <b><u>large</u></b> numbers and you are 
                likely to get overflow, or time limit.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">It's up to you to design any 
                algorithm that can solve this.<br>
                However, the basic idea is how to make algorithm like this:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1. Simplifies n! / (r!*(n-r)!) to 
                simpler form.<br>
                &nbsp;&nbsp;&nbsp;
                Example: 5C2 = 5! / (2!*(5-2)!) = 5! / (2!*3!) = 
                5*4*3*2*1/2*1*3*2*1 = 5*2<br>
                2. And then multiply the simplest 
                form of nCr (5*2) = 10<br>
                3. Output the result. Using this 
                trick, you will not get overflow error.</font></p><h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="531 - Compromise">531 - Compromise</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">If the normal LCS compare characters, this 
                version compare strings..., just re-use your LCS algorithm and adjust it 
                to compare strings... done</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="532 - Dungeon Master">532 - Dungeon Master</a> (by: Felix Halim)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">2-D maze problems are very familiar. This 
                problem is similar, but in 3-D. Fortunately, you don't need to worry much 
                about the complexity of moving to 3-D space..., you can simply re-use your 
                BFS code without major modifications.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="533 - Equation Solver">533 - Equation Solver</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A bit complex... Given the grammar of the 
                math in BNF, calculate the unknown variable. You can simulate this using 
                elementary school technique..., quite troublesome, I know, but doable...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="534 - Frogger">534 - 
                        Frogger</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
            <font face="Verdana" size="2">A frog's jump range is <u>must be 
                at least as long as the longest jump</u> occurring in the 
            sequence. </font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The frog distance (minimax 
                distance) between two stones therefore is defined as the minimum 
                necessary <u>jump range</u> (NOT total jumps) over all possible 
            paths between the two stones.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Example:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">2<br>
                0 0<br>
                3 4</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Output -&gt; 5.000, direct jump from 
                stone freddy stone to fiona stone</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">3<br>
                0 0<br>
                3 4<br>
                3 0</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Output -&gt; 4.000<br>
                <br>
                Jump from freddy stone (0,0) to intermediate stone (3,0), 
                range-&gt;3.000, then jump from intermediate stone (3,0) to fiona 
                stone (4,0), range-&gt;4.000. The longest jump in this sequence is 
                4.000, therefore the jump range for this sequence is 4.000.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This sequence is smaller than 
                direct jump (example 1 above) which is 5.000, so, for this test 
                case, you output 4.000 (minimum necessary jump range).</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Algorithm: All Pairs Shortest 
                Path, for example: Floyd Warshall algorithm.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="535 - Globetrotter">535 
                        - Globetrotter</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use spherical / geometrical distance 
                formula. Read more <a href="prog_computationalgeometry.html">here</a>.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="536 - Tree Recovery"><font face="Verdana" size="2">536 
                        - Tree Recovery</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You are given two representation 
                of a tree, the preOrder and inOrder representation.<br>
                You have to re-build the tree and output the tree in postOrder 
                representation.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use Tree Recursion, recursively 
                partition the string based on this fact:<br>
                the first element of preOrder is the root, find this root in 
                inOrder representation, partition the string according to that 
                root, recursively. </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="537 - Artificial Intelligence?">
                        537 - Artificial Intelligence?</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem is basically simple, 
                compute P=U*I or U=P/I or I=P/U. However, parsing the input can be harder 
                than the problem itself :). Master your programming language I/O skill in 
                order to parse the input correctly...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="538 - Balancing Bank Accounts">538 - Balancing Bank Accounts</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Sort the input and greedily assign the money 
                properly... </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left">
                <b>
                    <font face="Verdana" size="2">
                    <a name="539 - The Settlers of Catan">539 - The Settlers of Catan</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simple backtracking will solve this problem. 
                Just explore everything... The number of node and edges are small (less 
                than 25). </font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2">
                    <a name="540 - Team Queue">540 - Team Queue</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Even though the problem description is clear 
                and should be easy... The size of input will be the real problem. "In 
                constant time" may be impossible (not sure)... but binary search (log n) 
                is sufficient (I get accepted). This problem can be a good test for 
                testing how efficient your code is (in terms of memory and speed).</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="541 - Error Correction"><font face="Verdana" size="2">
                        541 - Error Correction</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Error correction mainly used in 
                Computer system's memory management. There are even parity and 
                odd parity. In this problem, we have to check even parity.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Count the number of ``1'' for each 
                rows and columns, all of them must be even.<br>
                If there exist one or more error, do this:<br>
                <br>
                If the error is on the same ROW and COLUMN, then output "change 
                bit (row,col)"<br>
                else output "corrupt"</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="543 - Golbach's Conjecture">
                        <font face="Verdana" size="2">543 - Golbach's Conjecture</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simulate this: "Every even number 
                greater than 4 can be written as the sum of two odd prime 
                numbers."</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Store a prime list in array (up to 
                n), find the pair (If there is more 
                than one pair of odd primes adding up to <i>n</i>, choose the 
                pair where the difference <i>b</i> - <i>a</i> is maximized.)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This line is, however, will not be 
                executed...(If I'm not mistaken) (If there is no such pair, 
                print a line saying ``<tt>Goldbach's conjecture is wrong.</tt>")</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="544 - Heavy Cargo">544 - 
                        Heavy Cargo</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Whenever you encounter a phrase like 
                "maximize the minimum" in a problem statement... you can guess that the 
                problem has to do with All Pairs Shortest Path, Floyd Warshall maximin 
                variant. Try it.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="551 - Nesting a Bunch of Brackets">551 - 
                        Nesting a Bunch of Brackets</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use a stack, push when you encounter open 
                bracket, pop when you encounter close bracket. Errors will occurs if the 
                popped item is not matching with current close bracket, or when at the 
                end, the stack is not empty...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="555 - Bridge Hands"><font face="Verdana" size="2">555 - 
                        Bridge Hands</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simple card simulation. Simply 
                deal those card to 4 piles (remember starting position, it can 
                be from North, East, South or West). After that, sort the piles 
                according to this problem rules.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="556 - Amazing">556 - 
                        Amazing</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A simulation of robot movement..., just do 
                according to problem description.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="557 - Burger">557 - 
                        Burger</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Refer to your discrete mathematic 
                books (probability theory)</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Probability a child get a 
                hamburger =&gt; (1/2)^x, <br>
                where x=people-2 because we want to keep Ben &amp; Bill get the same 
                burger<br>
                since this flipping is done sequentially, first child get 
                (1/2)^x,<br>
                second child get (1/2)^x * (1/2)^x, and so on...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="558 - Wormholes">558 - 
                        Wormholes</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Construct the graph, and then pass this 
                graph to your Bellman Ford Shortest Path algorithm. Bellman Ford can 
                detect the presence of negative cycle, and this is what you want to 
                know...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="562 - Dividing Coins">562 - 
                        Dividing Coins</a> (by: Abdullah Al Mamun)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use one dimensional, left to right 
                traversal, dynamic programming.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="567 - Risk">567 - 
                        Risk</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This is an All Pairs Shortest Path problem. 
                However, since total vertex is small (at most 20 countries), a simple 
                brute force DFS/BFS will do...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="571 - Jugs">571 - 
                        Jugs</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Another backtracking problem. You have 6 
                branching factors (6 type of moves). Perform this backtracking by 
                disallowing repeated cycles (by storing a flag in memory that you already 
                visit a similar jugs configuration before). The main problem here is just 
                the Time Limit...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="572 - Oil Deposits">572 - 
                        Oil Deposits</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Another backtracking problem... (There are a 
                lot of backtracking problem in this volume). Starting from a particular 
                '@' cell, flood fill it to 8 directions..., then find the number of 
                components.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="573 - The Snail">573 - 
                        The Snail</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">A simple problem, but there are several 
                traps:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1. Beware when fatique&lt;0, the snail will not 
                fall down again<br>
                2. If the snail already manage to get out, don't come back !!!</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="574 - Sum It Up">574 - 
                        Sum It Up</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Again..... another backtracking problem. 
                Backtrack, prune, backtrack, prune...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="575 - Skew Binary">575 - 
                        Skew Binary</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Base number, but 'skewed'... so, use the new 
                rule to convert the binary -&gt; decimal.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="576 - Haiku Review">576 - 
                        Haiku Review</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Hm... just follow the rules... I can't tell 
                much...</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="579 - Clock Hands"><font face="Verdana" size="2">579 - 
                        Clock Hands</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You have to determine the angle 
                between 2 clock hands.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Use this simple algorithm:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">hAngle=h*30+(m/60)*30; // Angle 
                from 12o'clock to hour hand<br>
                mAngle=m*6;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                // Angle from 12o'clock to minute hand<br>
                angle=abs(hAngle-mAngle);<br>
                if (angle&gt;180) angle=360-angle;</font></p>
            <h2 style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Common Mistake</font></h2>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1. Forget to subtract the angle 
                with 180 if it is larger 180 (They want the smallest angle)<br>
                2. This is 12 hour clock !!! Clock 
                with hands usually 12-hour clock !!!</font></p><h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="580 - Critical Mass">580 - Critical 
                        Mass</a> (by: Rupam)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2"><b><i>n</i></b> L's or U's can stacked up
                <b><i>2^n</i></b> ways. Say, there is <b><i>x</i></b> ways of arranging 
                stacks in which, there are no more than 2 consecutive U's. Then, number 
                of ways stacks can be arranged in which there is at least one occurrence 
                of three consecutive U's, can be written as:<br>
                <b><i>C(n) = 2^n - x</i></b>.<br>
                <br>
                Now, <b><i>x</i></b> can be denoted as <i><b>A(n)</b></i>, number of 
                ways of arranging stacks of <b><i>n</i></b> L's or U's in which, there 
                are no more than 2 consecutive U's and lets name this type of 
                arrangement: <i>B type</i>.<br>
                <br>
                Then <i><b>n</b></i> things of <i>B type</i> can be seen as:<br>
                <br>
                _______________ = ________________L + _______________LU + 
                ________________LUU<br>
                n things of B type&nbsp;&nbsp;&nbsp; n-1 things of B type&nbsp;&nbsp;&nbsp; n-2 things of B 
                type&nbsp;&nbsp;&nbsp;&nbsp;n-3 things of B type<br>
                <br>
                The right hand side permutations makes n things of B type as well, so 
                both sides are equal.<br>
                Therefore,<i> A(n) = A(n-1) + A(n-2) + A(n-3)<br>
                </i>where, <i>A(1) = 2, A(2) = 4, A(3) = 7</i><br>
                these are base cases for <i>B type</i> when n = 1,2, and 3<br>
                <br>
                In mathematic, there is a special series called "Tribonacci series", 
                where<br>
                <i><b>T(n) = T(n-1) + T(n-2) + T(n-3)<br>
                    </b></i>with base cases:<br>
                <i>T(1) = 1, T(2) = 1, T(3) = 2</i><br>
                <br>
                Our series A(n) can be transformed to Tribonacci series =&gt; <b><i>A(n) = 
                        T(n+2)</i></b><br>
                Therefore:</font></p><p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2"><b><i>C(n) = 2^n - x<br>
                        C(n) = 2^n - A(n)<br>
                        C(n) = 2^n - T(n+2)</i></b><br>
                <br>
                So, just implement this <b><i>C(n)</i></b> formula :)</font></p><p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Actually, whoever understands the problem 
                this way, before knowing that the solution is <b><i>2^n - T(n+2)</i></b> 
                can go easily without knowing Tribonacci series, using A(n).</font></p><h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="583 - Prime Factors"><font face="Verdana" size="2">583 
                        - Prime Factors</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This problem wants us to convert a 
                number to its Prime factors. Very similar to 516, but this one 
                is simpler. Solution:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1. Take the input X.<br>
                2. Start with a counter=2.<br>
                3. If counter can properly divide X 
                then print counter and divide X by counter.<br>
                4. If counter&gt;=sqrt(X), stop and 
                print X directly, remember divisibility property.<br>
                5. If X=1 then stop else go back to 
                step 3.</font></p><h2 style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Common Mistake</font></h2>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">1. Remember what to print for negative numbers and when to print 
                " x " symbol.<br>
                2. Time limit. Remember this divisibility property: No number &gt; sqrt(X) can 
                properly divide X.</font></p><h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="584 - Bowling">584 - Bowling</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Another simulation problem. There are many 
                ways to solve this problem, pick the one that is easiest for you. 
                Familiarize yourself with bowling scoring rule as described in problem 
                description. There is no trap in this problem. As long as you can model 
                the scoring rule in your code, you'll get accepted.</font></p><h1 style="margin-left: 10; margin-right: 10" align="left">
                <b>
                    <a name="587 - There's treasure everywhere!">
                        <font face="Verdana" size="2">587 - There's treasure everywhere!</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Simply move according to the input 
                data. At the final destination, just compute the distance 
                between final destination and point (0,0) using standard 
                phytagoras calculation.</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Start with initial value 
                x=10e-12 &amp;&amp; y=10e-12, I don't know why, but using this trick&nbsp; 
                your program will get accepted, otherwise, you will possible 
                got WA.</font></p><h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="589 - Pushing Boxes">589 - 
                        Pushing Boxes</a> (by: Arif Uzzaman)</font></b></h1>
            <div>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Verdana" size="2">Two bfs functions are needed. One for you and 
                    one for box. But you have to be careful on some point.&nbsp;</font></p></div>
            <div>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Verdana" size="2">In bfs function for the box:<br>
                    - in general bfs algorithm one node is visited only once but in this case a 
                    node can visited more than once.<br>
                    - the box can visit a node from east once, from west once, from south once 
                    and from north once. so a node can be visited by a box 4 times except the 
                    initial node for the box, it can be visited at most five times.</font></p></div>
            <div>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Verdana" size="2">Some critical inputs:<br>
                    </font><font face="Courier New" size="2">12 11 <br>
                    ###########<br>
                    #.#.......#<br>
                    #.###..####<br>
                    #...#...#.#<br>
                    #####.##..#<br>
                    #.....#...#<br>
                    ##.##...###<br>
                    #....B..T##<br>
                    #...#.#####<br>
                    #####.S..##<br>
                    ##...######<br>
                    ###########<br>
                    12 11 <br>
                    ###########<br>
                    #.#.......#<br>
                    #.###..####<br>
                    #...#...#.#<br>
                    #####.##..#<br>
                    #...#.#...#<br>
                    ##.##...###<br>
                    #....B..T##<br>
                    #...#.#####<br>
                    #####.S..##<br>
                    ##...######<br>
                    ###########<br>
                    12 11 <br>
                    ##.....####<br>
                    #.........#<br>
                    #.###.#.###<br>
                    #...#...#.#<br>
                    #####.##..#<br>
                    #...#.#...#<br>
                    ##.##...###<br>
                    #....B..T##<br>
                    #...#.#####<br>
                    #####.S..##<br>
                    ##...######<br>
                    ###########</font></p></div>
            <div>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Verdana" size="2">output:<br>
                    </font><font face="Courier New" size="2">Maze #1<br>
                    wnNwwwnneeeSnwwwsseeEEE</font></p></div>
            <div>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Courier New" size="2">Maze #2<br>
                    wnNNNNNennwSSSSSesWWWswwnEEEEEE</font></p></div>
            <div>
                <p style="margin-left: 10; margin-right: 10" align="left">
                    <font face="Courier New" size="2">Maze #3<br>
                    wnNNNNNeennwwSSSSSesWWWswwnEEEE<wbr>EE</font></p></div>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="591 - Box of Bricks"><font face="Verdana" size="2">591 
                        - Box of Bricks</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">There are a lot of programming 
                problem similar to this one, memorize this useful technique (If 
                you want).</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Example: 5 2 4 1 7 5</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Sum all items =&gt; 5+2+4+1+7+5=24<br>
                Find the average value =&gt; 24/6=4<br>
                Do a looping from first item, count the differences from the 
                average, get the absolute value<br>
                5-4 = 1&nbsp; =&gt; 1<br>
                2-4 = -2 =&gt; 2<br>
                4-4 = 0&nbsp; =&gt; 0<br>
                1-4 = -3 =&gt; 3<br>
                7-4 = 3&nbsp; =&gt; 3<br>
                5-4 = 1&nbsp; =&gt; 1<br>
                Sum the absolute difference =&gt; 1+2+0+3+3+1=10<br>
                Divide by 2 (because you don't have to do it twice, think about 
                it) =&gt; 10/2=5<br>
                Output the result = 5</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <a name="594 - One Little, Two Little, Three Little Endians">
                        <font face="Verdana" size="2">594 - One Little, Two Little, 
                        Three Little Endians</font></a></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">You need to swap bits!</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The input is an integer N, convert 
                this to 32-bit integer. You have to swap 8 bits of Least 
                Significant Bit to Most Significant Bit. Partition them into 
                this:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">X1 X2 X3 X4</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">Where X1,2,3, &amp; 4 is 8-bit from 
                the complete 32-bit integer.<br>
                Then you need to swap it so the position is like this:</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">X4 X3 X2 X1</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">So, use bitwise manipulation</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">&lt;&lt; Shift Left<br>
                &gt;&gt; Shift Right<br>
                &amp; bitwise And</font></p>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">The implementation is up to you.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" align="left"><b>
                    <font face="Verdana" size="2"><a name="598 - Bundling Newspaper">598 - 
                        Bundling Newspaper</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" align="left">
                <font face="Verdana" size="2">This is a simple backtracking enumeration 
                problem. The only problem that you may encounter is in reading the 
                multiple input format precisely. Other than that, this is just a simple 
                brute-force enumeration problem using backtrack. Btw, no need to sort 
                the newspaper names. The terms "lexicographic" in the problem refer to 
                the notation A,B,C,D given in the problem, that is, you enumerate using 
                the order given in the input, not based on the newspaper name.</font></p>


        </div>
    </div>
</div>
