<div data-page="10800" class="page">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="left"><a href="index.html" class="back link icon-only"><i class="icon icon-back"></i></a></div>
            <div class="center">Volume 108 (10800-10899)</div>
        </div>
    </div>

    <div class="page-content">
        <div class="content-block">



            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><b>
                    <font face="Verdana" size="2"><a name="10800 - Not That Kind of Graph">10800 - 
                        Not That Kind of Graph</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">This is a string processing 
                    problem, just follow the problem description. To help you determine whether 
                    you already get a correct implementation or not, let me give you several 
                    examples (see the highlighted text to view the whitespaces):</font></span></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">Input:</font></span></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">4<br>
                    RCRFCRFFCCRRC<br>
                    FFFCCC<br>
                    RFCRFC<br>
                    CCCRRF</font></span></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">Output:</font></span></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Courier New" size="2">
                    <span style="background-color: #00FFFF">Case #1:<br>
                        |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _<br>
                        |&nbsp; _/\_/\&nbsp;&nbsp;&nbsp; /<br>
                        | /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \__/<br>
                        +---------------<br>
                        <br>
                        Case #2:<br>
                        | \<br>
                        |&nbsp; \<br>
                        |&nbsp;&nbsp; \___<br>
                        +--------<br>
                        <br>
                        Case #3:<br>
                        | /\_/\_<br>
                        +--------<br>
                        <br>
                        Case #4:<br>
                        |&nbsp;&nbsp;&nbsp;&nbsp; /\<br>
                        | ___/<br>
                        +--------</span><br>
                    </font><font face="Verdana" size="2"><br>
                    </font></span><b>
                    <font face="Verdana" size="2"><a name="10801 - Lift Hopping">10801 - 
                        Lift Hopping</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">This problem, although is a 
                    bit weird for real-life situation, can be transformed into graph problem. 
                    Give edges between floors that can be served within one lift, the weight of 
                    this edges is the gap between floors * time required by this lift to move 
                    one floor. Also, add another edges that connects two lifts if they stop at 
                    the same floor, give weight 60. The solution is the shortest path from floor 
                    0 to floor k by traversing this graph. Please use Dijkstra algorithm.</font></span></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <b>
                    <font face="Verdana" size="2"><a name="10803 - Thunder Mountain">10803 - 
                        Thunder Mountain</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">A simple all-pairs shortest 
                    path problem. Firstly, build a distance matrix (use floating point). Set the 
                    distance to a very big number (say, 1 million) if it is bigger than 10 km. 
                    Then, perform floyd warshall algorithm to obtain the shortest path from any 
                    pair of towns. Then, pick the longest path among these shortest path 
                    distances, this will be your answer... if the answer is greater than 1 
                    million, then output "Send Kurdy" since there exist a pair of town that are 
                    unreachable.</font></span></p>
            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><b>
                    <font face="Verdana" size="2"><a name="10810 - Ultra-QuickSort">10810 - 
                        Ultra-QuickSort</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">This problem is actually a 
                    problem of counting "inversion index" using merge sort. Since merge sort 
                    runs in O(n lg n), 500.000 lg<sub>2</sub> 500.000 ~~ 10.000.000 operations... doable...</font></span><font face="Verdana" size="2"> To compute inversion index, merge sort can be 
                slightly modified. When the right partition goes in first in merge step, 
                that means all the remaining items in left partition &lt; first element in 
                right partition (i.e. you have to swap with all of them). Note: since the number of such <i>op</i> swaps 
                can be very large, you must use unsigned long long to store <i>op</i>.</font> </p>
            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><b>
                    <font face="Verdana" size="2"><a name="10812 - Beat the Spread!">10812 - 
                        Beat the Spread!</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">From the problem 
                    description, we know that:</font></span></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">score1 + score2 = s, and<br>
                    score1 - score2 = d (assuming score1 &gt;= score2).</font></span></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">Therefore:</font></span></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">score1 = (s+d)/2<br>
                    score2 = s-score1</font></span></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">This formula will only 
                    valid if (s+d)%2 == 0 and score1 &gt;= 0 and score2 &gt;= 0.</font></span></p>
            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><b>
                    <font face="Verdana" size="2"><a name="10813 - Traditional BINGO">10813 - 
                        Traditional BINGO</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">This problem is quite 
                    straightforward. Just follow the description given in the problem 
                    description. For the 'free space' in the center, mark it from the beginning, 
                    that's all...</font></span></p>
            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><b>
                    <font face="Verdana" size="2"><a name="10815 - Andys First Dictionary">10815 
                        - Andy's First Dictionary</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">Simple string processing 
                    problem. Tokenize each word (word is defined as sequences of a-z/A-Z <b>
                        only!</b>), lowercase them, and then hash them to a good hashtable (in C++, 
                    I use STL map). Finally, output the strings in sorted order.</font></span></p>
            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><b>
                    <font face="Verdana" size="2"><a name="10820 - Send a Table">10820 
                        - Send a Table</a></font></b></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">This is what I can derive 
                    so far:<br>
                    TotalPrecalculated[1] = 1; // base case<br>
                    TotalPrecalculated[i] = TotalPrecalculated[i-1] + 2*(number of occurrences 
                    of j, j&lt;=i, and gcd(j,i) == 1)</font></span></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <span lang="en-gb"><font face="Verdana" size="2">I think I will going to 
                    pre-calculate this values up to 50000, store it in a table, and then send 
                    this table to the judge?...</font></span></p>
            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2"><a name="10843 - Anne_s game">10843 - Anne's game</a></font><b><font face="Verdana" size="2"> 
                    (by: Niaz Morshed Chowdhury)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">This problem looks very tough but only to them who 
                don’t know Cayley’s formula. It gives the number of distinct spanning trees in a 
                complete graph on n vertices. </font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Basic formula :&nbsp; n^(n-2). </font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">But for higher value of n, like n = 100, you can 
                easily understand the situation. It will cause overflow. So, to avoid this 
                problem, we can take the help of Number Theory. From Chinese Remainder rule we 
                know, In case of consecutive multiplying if we MOD a&nbsp; number at each step of 
                multiply by a particular number then the result will be same as the result of 
                doing MOD at the end of the multiplications that particular number.&nbsp;&nbsp;&nbsp; </font>
            </p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><u>
                <font face="Verdana" size="2">Example</font></u></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">22 * 1 = 44<br>
                44 * 2 = 88<br>
                88 * 3 = 264</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">264 % 10 = 4</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">But,</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">22 * 1 = 44 % 10 = 4<br>
                4 * 2 = 8 % 10 = 8<br>
                8 * 3 = 24 % 10 = 4</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">So, we can see the result is same in both the 
                cases. In this problem we just need to write a function that will find the power 
                of any number and at each intermediate step it will MOD the result by 
                2000000011. Then there will be no chance of having Over Flow.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2"><a name="10849 - Move the Bishop">10849 - Move the 
                    Bishop</a></font><b><font face="Verdana" size="2"> (by: Niaz Morshed Chowdhury)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">For this problem we can say that a bishop needs to 
                move at best twice to go from any square to another one. WHY? Very simple! Look 
                at the chess board. You can understand it.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="center">
                <img src="img/10849.jpg" height="228" border="0" width="231"></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">So, the possible results will be:<br>
                0 – if the source and destination is same.<br>
                1 – if the source and destination situated on the same line. (In the picture for 
                black we have shown the lines by red and green colors.)<br>
                2 – if the source and destination situated&nbsp; on the same color but different 
                line.<br>
                no move – if source and destination situated on different color.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">We will be given N (matrix size) and x1,y1 
                (source), x2,y2 (destination)</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Use if else just following this order!</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><u>
                <font face="Verdana" size="2">Case # 1 : Out of the board</font></u></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">If&nbsp;any one of x1,y1,x2,y2 is greater than N then 
                “no move”<br>
                Explanation: As the board size is N, no value can not be greater than it.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><u>
                <font face="Verdana" size="2">Case # 2 : Source and Destination is same</font></u></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">If x1=x2 and y1=y2, then “0”<br>
                Explanation: As source and destination are same.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><u>
                <font face="Verdana" size="2">Case # 3 : On the same line (Red lines in the 
                picture)</font></u></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">if&nbsp; abs(x1-x2) = abs(y1-y2), then “1”.<br>
                Explanation: Look at the picture along red lines. 1,3 – 2,4 – 3,5 – 4,6 etc.<br>
                At each square index is increasing by 1 in both x and y axis. So, if the 
                difference of&nbsp; x and y of source and destination is same then they will be on 
                the same line.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><u>
                <font face="Verdana" size="2">Case # 4 : On the Same line (Green Lines in the 
                picture)</font></u></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">if x1+y1 = x2+y2 , then “1”.<br>
                Explanation: Look at the picture along green line. 1,7 – 2,6 – 3,5 – 4,4 etc.<br>
                At each square index is decreasing by 1 in y axis and increasing by 1 in x axis. 
                As a result, sum is always same. So, if the sum of [x,y](source) and sum of [x,y](destination) 
                is same then they will be on the same line.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><u>
                <font face="Verdana" size="2">Case # 5 : On the same color (For white)</font></u></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">if x is odd and y is even&nbsp; or if x is even or y is 
                odd then this square is white.<br>
                Now, if source and destination is white and case 1 to 4 fails, then answer is 
                “2” <br>
                Explanation: This is just my observation. Look at the picture. You can also 
                understand it.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><u>
                <font face="Verdana" size="2">Case # 6 : On the same color (For Black)</font></u></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">if x and y both are even or if x and y both are 
                odd then this square is Black.<br>
                Now, if source and destination is Black and case 1 to 4 fails, then answer is 
                “2”<br>
                Explanation: This is just my observation. Look at the picture. You can also 
                understand it.&nbsp;</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><u>
                <font face="Verdana" size="2">Case # 7 : Un reachable</font></u></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">If case 1 to 6 fails then unreachable. So, the 
                answer is “no move”.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="10851_-_2D_Hieroglyphs_decoder">10851 
                        - 2D Hieroglyphs decoder</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Just make use of the fact that any positive 
                integer can be written in the form a0 * 2 ^ 0 + a1 * 2 ^ 1 + ... + an * 2 ^ n, 
                where ai = 0 or 1. So if b(i, c) == '\', it means in the binary representation 
                of c, ai-1 = 1.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2"><a name="10852_-_Less_Prime">10852 - Less Prime</a></font><b><font face="Verdana" size="2"> 
                    (by: Niaz Morshed Chowdhury)</font></b></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">This is actually an easy prime problem. Problem wants, “Let n be an integer, 100 ≤ n ≤ 
                10000, find the prime number x, x ≤ n, so that n-p*x is maximum, where p is an 
                integer such that p*x ≤ n &lt; (p+1)*x.” If we simplifies this statement then we 
                can locate the position of the desired prime number! If n is the input then our desired prime number 
                will be just the prime number after/from this number “k = n/2 + 1”. Now, 
                generate the prime numbers and check according to this statement and you will 
                easily get it accepted.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left"><u>
                <font face="Verdana" size="2">Example:</font></u><font face="Verdana" size="2"><br>
            n = 101<br>
            k = n/2 + 1 = 50 + 1 = 51.<br>
            So the next prime number from this number is 53.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Alternative: A mathematics problem. Deduce that p 
                = 1. The problem is to find the first prime number that is &gt;= n / 2 + 1. Do so 
                using the <br>
                sieving technique.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="10854_-_Number_of_Paths">10854 - 
                        Number of Paths</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Write a recursive-descent parser like method to 
                parse the input and count the number of paths.<br>
                <br>
                <b><a name="10855_-_Rotated_Square">10855 - Rotated Square</a></b></font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Simple ad-hoc problem. Use the formula (i, j) =&gt; 
                (j, n - 1 - i) to rotate the small square 90 degrees to the right.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="10856_-_Recover_Factorial">10856 - 
                        Recover Factorial</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Pre-calculate the number of prime factors of n! 
                for n = 0...2800000 and store in array a. Then do a binary search on array a for 
                each input.<br>
                <br>
                <b><a name="10858_-_Unique_Factorization">10858 - Unique Factorization</a></b></font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Use a recursive function Factorize(stack s, int N) 
                to print (and count) all the ways N can be uniquely factorized.<br>
                <br>
                <b><a name="10862_-_Connect_the_Cable_Wires">10862 - Connect the Cable Wires</a></b></font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">The number of ways to connect for n houses can be 
                calculated using the formula: f(n) = 3 * f(n-1) - f(n-2). f(1) = 1, f(2) = 3. 
                Use Java's BigInteger class.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2"><a name="10865_-_Brownie_Points_I">10865 - Brownie 
                    Points I</a> (by: Niaz Morshed Chowdhury)</font></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">This is actually a checking problem. At first we 
                need to find the dividing line region. Then will start to check for each point 
                based on some criteria for Stan and Olie. Here goes the algorithm.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Courier New" size="2">k=N/2+1; // mid point that is actually the 
                dividing line region.<br>
                x=a[k]; // a[] holds the X co-ordinate value and x is the X of the mid point.<br>
                y=b[k]; // b[] holds the Y co-ordinate value and y is the Y of the mid point.<br>
                <br>
                stan=0; // Initially both of them have 0 score.<br>
                olie=0;</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Courier New" size="2">for (i=1; i&lt;=N; i++) {<br>
                &nbsp; if ((a[i]&gt;x &amp;&amp; b[i]&gt;y)||(a[i]&lt;x &amp;&amp; b[i]&lt;y)) // Criteria for Stan<br>
                &nbsp;&nbsp;&nbsp; stan++;<br>
                &nbsp; if ((a[i]&gt;x &amp;&amp; b[i]&lt;y)||(a[i]&lt;x &amp;&amp; b[i]&gt;y)) // Criteria for Olie<br>
                &nbsp;&nbsp;&nbsp; olie++;<br>
                }</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Just print the value of stan and olie.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Alternative: An ad-hoc problem. Simply follow the 
                rules to calculate each person's points.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="10871_-_Primed_Subsequence">10871 - 
                        Primed Subsequence</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">A mathematics problem. Use the sieve method to 
                pre-calculate all the prime numbers up to 1000000. Then try all the possible 
                lengths of subsequence, starting from the smallest (2) to the largest(n).</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="10874_-_Segments">10874 - Segments</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">A DP problem. Number the end points of the 
                segments from left to right, top to bottom: 0, 1, 2... Let Best(pi) be the 
                shortest path from point pi to point (n, n). If pi is the left end of a segment, 
                the next point to go on the next line can be pi + 2 or pi + 3. If pi is the 
                right end of a segment, the next point to go on the next line can be pi + 1 or 
                pi + 2. Choose the shortest path among the two ways.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2"><a name="10878_-_Decode_the_tape">10878 - Decode 
                    the tape</a> (by: Niaz Morshed Chowdhury)</font></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Very easy problem. To solve this problem at first 
                you need to decode what the problem actually wants. In the problem description 
                you can not find any type of hint of actually what you need to do! The only 
                clue is the sample input and which is really sufficient.&nbsp;Look at the sample input. You will get something 
                like this one:</font><font face="Courier New" size="2"><br>
                ___________<br>
                | o&nbsp;&nbsp; .&nbsp; o|<br>
                |&nbsp; o&nbsp; .&nbsp;&nbsp; |<br>
                | ooo .&nbsp; o|<br>
                | ooo .o o|<br>
                ___________</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Just ignore the first and the last line. Consider 
                from second to second last line and also ignore there the first (from left), 7th 
                and 11th character. From rest of the character consider ‘space’ as ZERO and ‘o’ 
                as ONE. Now convert this binary number to decimal and output the corresponding 
                character. Example:</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Courier New" size="2">| o&nbsp; &nbsp;.&nbsp; o|</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">x01000x001 =&gt; 01000001(b) =&gt; 65(d) =&gt; A.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Alternative: An ad-hoc problem. If we ignore the 
                '|' and '.' character, strings of the form " oo o " represent the binary form of 
                ASCII codes ('o' = 1, ' ' = 0). Simply convert the strings to ASCII codes and 
                output the corresponding characters.</font></p>
            <h1 style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2"><a name="10879_-_Code_Refactoring">10879 - Code 
                    Refactoring</a> (by: Niaz Morshed Chowdhury)</font></h1>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Trust me! Just find arbitrarily any two numbers 
                that forms the given number. Here you need to find two such pair. Its a special 
                judge problem and there is nothing called special or critical test case.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">My Process:<br>
                1. Start from 2 to find two divisor of the given number.<br>
                2. Now, divide the given number with these two numbers and get another two!<br>
                3. Just print them according to the given format and get it accepted.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Alternative: A mathematics problem. Factor K into 
                a * b * c (a and b are prime, a &lt; b), then output K = a * (b * c) = (a * b) * c. 
                Observe that b &lt; 3163 ( = sqrt(10000000)), a sieve can be used to find a and b.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="10880_-_Colin_and_Ryan">10880 - Colin 
                        and Ryan</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">A mathematics problem. List all the factors of C - 
                R that are &gt; R. To do so, loop i from 1 to sqrt(C - R); if (C - R) divides i and 
                i &gt; R then output i, and save (C - R) / i to output later.<br>
                <br>
                <b><a name="10891_-_Game_of_Sum">10891 - Game of Sum</a></b></font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">This problem can be solved using dynamic 
                programming. Let best(i, j) be the best difference the current player can get, 
                given the starting position (i) and the ending position (j). Let sum(i, j) be 
                the sum a[i]+...+a[j]. The dynamic programming formula is best(i, j) = 
                max(max(sum(i,i+k)-best(i+k,j),sum(j-k,j)-best(i,j-k))) for k = 0,...,j-i.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="10892_-_LCM_Cardinality">10892 - LCM 
                        Cardinality</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">A mathematics problem. Find all the divisors of n, 
                then find the number of pairs of divisors (m, n) such that gcd(m, n) = 1.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="10894_-_Save_Hridoy">10894 - Save 
                        Hridoy</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Store the characters as 5x5 arrays. Just draw each 
                'pixel' N times, and each line N times. Also remember to output 2 blank lines 
                after each test.<br>
                <br>
                <b><a name="10895_-_Matrix_Transpose">10895 - Matrix Transpose</a></b></font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Store the matrix as a vector of vector of pair of 
                int. The first element of the pair is the column index, the second is the 
                number. Create a new vector of vector which is the transpose of the original.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <b><font face="Verdana" size="2"><a name="10896_-_Known_Plaintext_Attack">10896 
                        - Known Plaintext Attack</a></font></b></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">An ad-hoc problem. Try all the possible keys. Use 
                strtok to tokenize the original string and compare each of the token with the 
                known word.</font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2"><b><a name="10897_-_Travelling_Distance">10897 - Travelling Distance</a></b></font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">Simple geometry problem. Convert latitudes and 
                longitudes to Cartesian coordinates and calculate the angle the two points make 
                with the center of the Earth. Multiplying that angle by the radius of the Earth 
                gives the answer.<br>
                <br>
                <b><a name="10898_-_Combo_Deal">10898 - Combo Deal</a></b></font></p>
            <p style="margin-left: 10; margin-right: 10" dir="ltr" align="left">
                <font face="Verdana" size="2">A DP problem. Let Best(s1, s2, s3, s4, s5, s6) be 
                the best price to buy the set (s1, s2, s3, s4, s5, s6). The DP formula is 
                Best(s1, s2, s3, s4, s5, s6) = (for all i) Best(s1 - ci1, s2 - ci2, s3 - ci3, s4 
                - ci4, s5 - ci5, s6 - ci6) + pi, where pi is the price of combo set i, and cij 
                is the number of item j in combo set i.</font></p>


        </div>
    </div>
</div>
